<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–Ü–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–∏–π JSON Comparator</title>
    <!-- AJV JSON Schema Validator - Latest Version with Additional Formats -->
    <!-- üéØ AJV v8.17.1: Core JSON Schema validation with Draft 4, 6, 7, 2019-09, 2020-12 support -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ajv/8.17.1/ajv.min.js" onerror="loadAjvFallback()"></script>
    <!-- üìß AJV Formats: email, date, time, uri, uuid, regex and other format validators -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ajv-formats/2.1.1/ajv-formats.min.js" onerror="console.warn('AJV Formats failed to load')"></script>
    <!-- üîß AJV Keywords: Additional validation keywords like instanceof, range, etc. -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ajv-keywords/5.1.0/ajv-keywords.min.js" onerror="console.warn('AJV Keywords failed to load')"></script>
    
    <!-- üìä Chart.js for Analytics and Visualizations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.min.js" onerror="console.warn('Chart.js failed to load')"></script>
    <script>
        // Fallback –¥–ª—è AJV –±—ñ–±–ª—ñ–æ—Ç–µ–∫–∏ –∑ –¥–æ–¥–∞—Ç–∫–æ–≤–∏–º–∏ –ø–∞–∫–µ—Ç–∞–º–∏
        function loadAjvFallback() {
            console.log('Loading AJV fallback with additional packages...');
            
            // –ó–∞–≤–∞–Ω—Ç–∞–∂—É—î–º–æ –æ—Å–Ω–æ–≤–Ω—É AJV –±—ñ–±–ª—ñ–æ—Ç–µ–∫—É
            const ajvScript = document.createElement('script');
            ajvScript.src = 'https://unpkg.com/ajv@8.17.1/dist/ajv.bundle.js';
            ajvScript.onload = function() {
                console.log('AJV core fallback loaded successfully');
                
                // –ó–∞–≤–∞–Ω—Ç–∞–∂—É—î–º–æ –¥–æ–¥–∞—Ç–∫–æ–≤—ñ —Ñ–æ—Ä–º–∞—Ç–∏
                const formatsScript = document.createElement('script');
                formatsScript.src = 'https://unpkg.com/ajv-formats@2.1.1/dist/ajv-formats.min.js';
                formatsScript.onload = function() {
                    console.log('AJV formats loaded successfully');
                    
                    // –ó–∞–≤–∞–Ω—Ç–∞–∂—É—î–º–æ –¥–æ–¥–∞—Ç–∫–æ–≤—ñ keywords
                    const keywordsScript = document.createElement('script');
                    keywordsScript.src = 'https://unpkg.com/ajv-keywords@5.1.0/dist/ajv-keywords.min.js';
                    keywordsScript.onload = function() {
                        console.log('AJV keywords loaded successfully');
                        window.AjvExtensionsLoaded = true;
                    };
                    keywordsScript.onerror = function() {
                        console.warn('AJV keywords failed to load via fallback');
                    };
                    document.head.appendChild(keywordsScript);
                };
                formatsScript.onerror = function() {
                    console.warn('AJV formats failed to load via fallback');
                };
                document.head.appendChild(formatsScript);
            };
            ajvScript.onerror = function() {
                console.warn('Primary AJV fallback failed, trying CDN alternatives...');
                
                // –°–ø—Ä–æ–±—É—î–º–æ —â–µ –æ–¥–∏–Ω fallback –∑ jsdelivr
                const fallbackScript = document.createElement('script');
                fallbackScript.src = 'https://cdn.jsdelivr.net/npm/ajv@8.17.1/dist/ajv.min.js';
                fallbackScript.onerror = function() {
                    console.error('All AJV loading attempts failed. Schema validation will be disabled.');
                    window.AjvLoadError = true;
                };
                document.head.appendChild(fallbackScript);
            };
            document.head.appendChild(ajvScript);
        }
        
        // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—ñ AJV —Ç–∞ –¥–æ–¥–∞—Ç–∫–æ–≤–∏—Ö –ø–∞–∫–µ—Ç—ñ–≤ –ø—ñ—Å–ª—è –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è
        function isAjvAvailable() {
            const ajvExists = (
                typeof Ajv !== 'undefined' ||
                typeof window.Ajv !== 'undefined' ||
                typeof window.ajv !== 'undefined' ||
                (window.Ajv && window.Ajv.default)
            );
            
            const available = ajvExists && !window.AjvLoadError;
            
            // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –¥–æ–¥–∞—Ç–∫–æ–≤—ñ –ø–∞–∫–µ—Ç–∏ (–Ω–µ –∫—Ä–∏—Ç–∏—á–Ω–æ –¥–ª—è —Ä–æ–±–æ—Ç–∏)
            const formatsAvailable = typeof addFormats !== 'undefined' || typeof window.addFormats !== 'undefined';
            const keywordsAvailable = typeof addKeywords !== 'undefined' || typeof window.addKeywords !== 'undefined';
            
            if (!available) {
                console.warn('AJV Library Status:', {
                    'typeof Ajv': typeof Ajv,
                    'typeof window.Ajv': typeof window.Ajv,
                    'typeof window.ajv': typeof window.ajv,
                    'window.Ajv.default': window.Ajv && window.Ajv.default,
                    'AjvLoadError': window.AjvLoadError,
                    'formatsAvailable': formatsAvailable,
                    'keywordsAvailable': keywordsAvailable
                });
            } else if (available) {
                console.log('AJV Status: ‚úÖ Core available, Formats:', formatsAvailable ? '‚úÖ' : '‚ùå', 'Keywords:', keywordsAvailable ? '‚úÖ' : '‚ùå');
                
                // Show version info if available
                try {
                    if (typeof Ajv !== 'undefined' && Ajv.version) {
                        console.log(`üì¶ AJV Version: ${Ajv.version}`);
                    }
                } catch (e) {
                    // Ignore version check errors
                }
            }
            return available;
        }
    </script>
    <style>
        :root {
            --bg-color: #f8f9fa;
            --main-color: #ffffff;
            --border-color: #dee2e6;
            --shadow-color: rgba(0, 0, 0, 0.05);
            --text-color: #212529;
            --header-color: #343a40;
            --accent-color: #007bff;
            --green: #28a745;
            --red: #dc3545;
            --blue: #007bff;
            --orange: #fd7e14;
            --purple: #6f42c1;
            --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            --toast-success-bg: #d4edda;
            --toast-success-color: #155724;
            --toast-error-bg: #f8d7da;
            --toast-error-color: #721c24;
            --toast-border-radius: 8px;

            /* JSON Syntax Highlighting CSS Variables (needed for tree view) */
            --json-key: #9c27b0;
            --json-string: #4caf50;
            --json-number: #2196f3;
            --json-boolean: #ff9800;
            --json-null: #f44336;
            --json-bracket: #4b4b4b;
            --json-comma: #4b4b4b;
            --json-colon: #4b4b4b;
        }

        body.dark-mode {
            --bg-color: #121212;
            --main-color: #1e1e1e;
            --border-color: #444;
            --shadow-color: rgba(0, 0, 0, 0.2);
            --text-color: #e0e0e0;
            --header-color: #ffffff;
            --toast-success-bg: #1f4a2d;
            --toast-success-color: #a7d9b5;
            --toast-error-bg: #5f2b2c;
            --toast-error-color: #f5c6cb;

            /* Dark mode JSON Syntax Highlighting */
            --json-key: #ba68c8;
            --json-string: #81c784;
            --json-number: #64b5f6;
            --json-boolean: #ffb74d;
            --json-null: #e57373;
            --json-bracket: #b0b0b0;
            --json-comma: #b0b0b0;
            --json-colon: #b0b0b0;
        }

        body {
            font-family: var(--font-family);
            margin: 0;
            background-color: var(--bg-color);
            background-image: linear-gradient(135deg, var(--bg-color) 0%, #e9ecef 100%);
            color: var(--text-color);
            line-height: 1.6;
            transition: background-color 0.3s;
        }
        
        body.dark-mode {
             background-image: linear-gradient(135deg, #121212 0%, #2c2c2c 100%);
        }

        .container {
            max-width: 1400px;
            margin: 20px auto;
            padding: 20px;
            transition: max-width 0.3s ease-in-out;
        }
        .container.full-width {
            max-width: 98%;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            position: relative;
        }
        .header h1 {
            color: var(--header-color);
            font-weight: 600;
        }

        /* Diff Highlighting for JSON View */
        .diff-added-text { background-color: rgba(40, 167, 69, 0.2); }
        .diff-removed-text { background-color: rgba(220, 53, 69, 0.2); }
        .diff-changed-text { background-color: rgba(0, 123, 255, 0.2); } /* For ValueChanged, TypeChanged, LengthChanged, SchemaError */

        body.dark-mode .diff-added-text { background-color: rgba(40, 167, 69, 0.3); }
        body.dark-mode .diff-removed-text { background-color: rgba(220, 53, 69, 0.3); }
        body.dark-mode .diff-changed-text { background-color: rgba(0, 123, 255, 0.3); }


        /* Top Controls (Theme, Settings, Width) */
        .top-controls { position: absolute; top: 10px; right: 20px; display: flex; align-items: center; gap: 15px; }
        .theme-switch-wrapper { display: flex; align-items: center; }
        .theme-switch { display: inline-block; height: 24px; position: relative; width: 50px; }
        .theme-switch input { display: none; }
        .slider { background-color: #ccc; bottom: 0; cursor: pointer; left: 0; position: absolute; right: 0; top: 0; transition: .4s; border-radius: 24px; }
        .slider:before { background-color: #fff; bottom: 4px; content: ""; height: 16px; left: 4px; position: absolute; transition: .4s; width: 16px; border-radius: 50%; }
        input:checked + .slider { background-color: var(--accent-color); }
        input:checked + .slider:before { transform: translateX(26px); }

        #settingsBtn, #widthToggleBtn { background: none; border: none; cursor: pointer; font-size: 1.4em; color: var(--text-color); opacity: 0.7; transition: opacity 0.2s, transform 0.2s; padding: 0; display: flex; align-items: center; justify-content: center; }
        #settingsBtn:hover, #widthToggleBtn:hover { opacity: 1; transform: scale(1.1); }
        #widthToggleBtn svg { width: 22px; height: 22px; }

        .mode-selector {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            background-color: var(--main-color);
            padding: 8px;
            border-radius: 12px;
            box-shadow: 0 2px 8px var(--shadow-color);
            border: 1px solid var(--border-color);
        }
        .mode-selector label {
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
            font-weight: 500;
        }
        .mode-selector input { display: none; }
        .mode-selector input:checked + .tooltip-container label {
            background-color: var(--accent-color);
            color: white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        /* Special positioning for mode selector tooltips */
        .mode-selector .tooltip-container {
            position: relative;
            display: inline-block;
        }
        
        .mode-selector .tooltip {
            min-width: 260px;
            max-width: 320px;
            text-align: left;
            z-index: 1001; /* Higher than normal tooltips to appear above other elements */
        }
        
        .tooltip strong {
            color: inherit;
            font-weight: 600;
        }
        
        .tooltip br {
            line-height: 1.6;
        }
        
        /* Remove leading/trailing whitespace for cleaner tooltip appearance */
        .tooltip {
            white-space-collapse: discard; /* Modern browsers */
        }
        
        .tooltip:empty::before {
            content: none;
        }
        .drop-zones {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        #dropZoneSchema { grid-column: span 2; } /* Schema takes full width */
        .drop-zone {
            border: 2px dashed var(--border-color);
            border-radius: 12px;
            background-color: var(--main-color);
            transition: all 0.2s;
            position: relative;
            padding: 10px;
            box-shadow: 0 4px 12px var(--shadow-color);
        }
        .drop-zone.invalid {
            border-color: var(--red);
        }
        .drop-zone.dragover {
            background-color: #e9ecef;
            border-color: var(--accent-color);
            transform: scale(1.02);
        }
        body.dark-mode .drop-zone.dragover { background-color: #2c2c2c; }
        .drop-zone textarea {
            width: 100%;
            height: 150px;
            border: none;
            outline: none;
            resize: none;
            padding: 20px;
            box-sizing: border-box;
            background-color: transparent;
            font-family: 'Courier New', Courier, monospace;
            font-size: 1em;
            color: var(--text-color);
        }
        .drop-zone .file-name { font-weight: 600; color: var(--accent-color); margin-top: 10px; display: block; text-align: center; padding-bottom: 10px;}
        .error-message {
            color: var(--red);
            font-size: 0.9em;
            padding: 0 15px 10px;
            text-align: left;
            display: none;
        }
        .controls { text-align: center; margin-bottom: 30px; display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; }
        .action-btn {
            padding: 12px 24px;
            font-size: 1.1em;
            font-weight: 600;
            color: #fff;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }
        #compareBtn { background-color: var(--accent-color); }
        #compareBtn:disabled { background-color: #6c757d; cursor: not-allowed; box-shadow: none; }
        #compareBtn:not(:disabled):hover { background-color: #0056b3; transform: translateY(-2px); }
        body.dark-mode .action-btn { background-color: #0056b3; }
        body.dark-mode .action-btn:hover { background-color: #004494; }

        .export-container { position: relative; display: inline-block; }
        #exportBtn { background-color: var(--green); }
        #exportBtn:hover { background-color: #218838; transform: translateY(-2px); }
        .export-dropdown { display: none; position: absolute; background-color: var(--main-color); min-width: 160px; box-shadow: 0 8px 16px 0 rgba(0,0,0,0.2); z-index: 1; border-radius: 8px; border: 1px solid var(--border-color); }
        .export-dropdown a { color: var(--text-color); padding: 12px 16px; text-decoration: none; display: block; }
        .export-dropdown a:hover { background-color: #f1f3f5; }
        body.dark-mode .export-dropdown a:hover { background-color: #2c2c2c; }
        .export-container:hover .export-dropdown { display: block; }
        #clearAllBtn, #copyResultsBtn { background-color: #6c757d; }
        #clearAllBtn:hover, #copyResultsBtn:hover { background-color: #5a6268; }
        
        #results {
            background-color: var(--main-color);
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 15px var(--shadow-color);
            display: none;
        }
        h2 { color: var(--header-color); border-bottom: 2px solid var(--border-color); padding-bottom: 10px; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th, td { padding: 12px; text-align: left; border-bottom: 1px solid var(--border-color); }
        th.sortable { cursor: pointer; user-select: none; position: relative; padding-right: 20px; }
        th.sortable::after { content: '‚Üï'; position: absolute; right: 8px; top: 50%; transform: translateY(-50%); opacity: 0.4; }
        th.sort-asc::after { content: '‚ñ≤'; opacity: 1; }
        th.sort-desc::after { content: '‚ñº'; opacity: 1; }
        pre { margin: 0; white-space: pre-wrap; word-break: break-all; font-family: 'Courier New', Courier, monospace; }
        
        /* Icon circles */
        .icon-circle {
            display: inline-flex;
            justify-content: center;
            align-items: center;
            width: 24px; /* Size of the circle */
            height: 24px; /* Size of the circle */
            border-radius: 50%;
            font-weight: bold;
            font-size: 0.8em; /* Size of the text/symbol inside */
            color: white; /* Text color inside the circle */
        }
        .icon-circle-added { background-color: var(--green); }
        .icon-circle-removed { background-color: var(--red); }
        .icon-circle-changed { background-color: var(--blue); } /* For üîÑ, üß±, üìè, ‚ùó, X */
        .icon-circle-total { background-color: var(--orange); } /* New color for total */
        
        .results-controls { margin-bottom: 20px; display: flex; gap: 20px; align-items: center; flex-wrap: wrap; padding: 10px; background-color: var(--bg-color); border-radius: 8px;}
        .results-controls input[type="search"] { padding: 8px 12px; border: 1px solid var(--border-color); border-radius: 6px; background-color: var(--main-color); color: var(--text-color); min-width: 250px; }
        .results-controls .filter-group { display: flex; gap: 15px; align-items: center; }
        .results-controls .filter-group label { display: flex; align-items: center; gap: 5px; cursor: pointer; }
        
        .stats-bar { 
            display: flex; 
            gap: 20px; 
            padding: 20px; 
            background-color: var(--bg-color); 
            border-radius: 12px; 
            margin-bottom: 20px; 
            align-items: center;
            flex-wrap: wrap;
            border: 2px solid var(--border-color);
        }
        .stat-item { 
            font-size: 1.1em; 
            font-weight: 500; 
            display: flex; 
            align-items: center; 
            gap: 8px; 
        }
        .stat-item-total {
            font-size: 1.3em;
            padding: 8px 16px;
            background-color: var(--main-color);
            border-radius: 8px;
            border: 1px solid var(--accent-color);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .stat-item-total strong {
            color: var(--accent-color);
        }
        .stats-divider {
            width: 2px;
            height: 30px;
            background-color: var(--border-color);
            margin: 0 10px;
        }
        
        /* Responsive design for stats */
        @media (max-width: 768px) {
            .stats-bar {
                flex-direction: column;
                align-items: stretch;
                gap: 15px;
            }
            
            .stats-divider {
                width: 100%;
                height: 2px;
                margin: 5px 0;
            }
            
            .stat-item-total {
                text-align: center;
            }
        }

        .json-view { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px; }
        .json-view pre {
            background-color: var(--main-color);
            padding: 15px;
            border-radius: 8px;
            line-height: 1.6em;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow: auto; /* Changed from visible for scrolling */
            border: 1px solid var(--border-color);
            margin: 0;
            font-size: 14px;
        }
        body.dark-mode .json-view pre {
            background-color: #1e1e1e;
            color: #e0e0e0;
        }

        /* JSON Syntax Highlighting */
        .json-key { color: var(--json-key); }
        .json-string { color: var(--json-string); }
        .json-number { color: var(--json-number); }
        .json-boolean { color: var(--json-boolean); }
        .json-null { color: var(--json-null); }
        .json-bracket { color: var(--json-bracket); }
        .json-comma { color: var(--json-comma); }
        .json-colon { color: var(--json-colon); }
        
        /* Collapsible Sections */
        .collapsible-header { width: 100%; background: transparent; border: none; padding: 0; text-align: left; cursor: pointer; display: flex; justify-content: space-between; align-items: center; }
        .collapsible-header h2 { border: none; }
        .collapse-icon { transition: transform 0.3s ease; color: var(--text-color); }
        .collapsible-content { max-height: 0; overflow: hidden; transition: max-height 0.4s ease-in-out; }
        .collapsible-section:not(.collapsed) .collapsible-content { max-height: 5000px; /* Arbitrary large value */ }
        .collapsible-section.collapsed .collapse-icon { transform: rotate(-90deg); }

        /* Loading Overlay */
        #loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1001; /* Higher than modal */
        }
        .loader-spinner {
            border: 8px solid #f3f3f3;
            border-top: 8px solid var(--accent-color);
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        /* Modal Styles */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); z-index: 1000; display: none; justify-content: center; align-items: center; animation: fadeIn 0.3s ease; }
        .modal-content { background: var(--main-color); padding: 30px; border-radius: 12px; box-shadow: 0 5px 20px rgba(0,0,0,0.2); width: 90%; max-width: 600px; animation: slideIn 0.3s ease; }
        .modal-header { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid var(--border-color); padding-bottom: 15px; margin-bottom: 20px; }
        .modal-header h2 { margin: 0; color: var(--header-color); border: none; }
        .modal-close { font-size: 2em; font-weight: bold; cursor: pointer; color: var(--text-color); background: none; border: none; }
        .modal-body .form-group { margin-bottom: 20px; }
        .modal-body label { display: block; font-weight: 600; margin-bottom: 8px; }
        .modal-body input[type="text"], .modal-body textarea { width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-color); color: var(--text-color); box-sizing: border-box; }
        .modal-body textarea { min-height: 80px; resize: vertical; }
        .modal-body .radio-group label { display: inline-block; margin-right: 15px; font-weight: normal; }
        .modal-body .checkbox-group { display: flex; align-items: center; gap: 10px; }
        .modal-footer { text-align: right; border-top: 1px solid var(--border-color); padding-top: 20px; margin-top: 20px; }
        
        /* Tooltip Styles */
        .tooltip-container {
            position: relative; /* –©–æ–± –ø—ñ–¥–∫–∞–∑–∫–∞ –ø–æ–∑–∏—Ü—ñ–æ–Ω—É–≤–∞–ª–∞—Å—è –≤—ñ–¥–Ω–æ—Å–Ω–æ —Ü—å–æ–≥–æ –µ–ª–µ–º–µ–Ω—Ç–∞ */
            display: inline-block; /* –©–æ–± –Ω–µ –∑–∞–π–º–∞–≤ –≤—Å—é —à–∏—Ä–∏–Ω—É */
            cursor: help; /* –Ü–Ω–¥–∏–∫–∞—Ç–æ—Ä, —â–æ —î –ø—ñ–¥–∫–∞–∑–∫–∞ */
        }

        .tooltip {
            visibility: hidden;
            opacity: 0;
            width: auto; /* –ê–¥–∞–ø—Ç–∏–≤–Ω–∞ —à–∏—Ä–∏–Ω–∞ */
            max-width: 280px; /* –û–ø—Ç–∏–º–∞–ª—å–Ω–∞ —à–∏—Ä–∏–Ω–∞ –¥–ª—è –∫—Ä–∞—â–æ–≥–æ –≤–∏—Ä—ñ–≤–Ω—é–≤–∞–Ω–Ω—è */
            background-color: var(--header-color);
            color: var(--main-color);
            text-align: left;
            border-radius: 8px;
            padding: 10px 14px; /* –¢—Ä–æ—Ö–∏ –∑–±—ñ–ª—å—à–µ–Ω–∏–π padding –¥–ª—è –∫—Ä–∞—â–æ–≥–æ –≤–∏–¥—É */
            position: fixed;
            z-index: 1000;
            font-size: 0.85em;
            line-height: 1.4; /* –ü–æ–∫—Ä–∞—â–µ–Ω–∞ –≤–∏—Å–æ—Ç–∞ —Ä—è–¥–∫–∞ */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
            pointer-events: none;
            white-space: pre-line; /* –ó–±–µ—Ä—ñ–≥–∞—î –ø–µ—Ä–µ–Ω–æ—Å–∏ —Ä—è–¥–∫—ñ–≤, –∞–ª–µ –≤–∏–¥–∞–ª—è—î –∑–∞–π–≤—ñ –ø—Ä–æ–±—ñ–ª–∏ */
            word-wrap: break-word; /* –ü–µ—Ä–µ–Ω–æ—Å–∏—Ç—å –¥–æ–≤–≥—ñ —Å–ª–æ–≤–∞ */
            overflow-wrap: break-word; /* –î–æ–¥–∞—Ç–∫–æ–≤–∞ –ø—ñ–¥—Ç—Ä–∏–º–∫–∞ –ø–µ—Ä–µ–Ω–æ—Å—É */
        }

        /* Dark mode adjustments for tooltip */
        body.dark-mode .tooltip {
            background-color: #555;
            color: #eee;
        }

        /* Toast notifications */
        #toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1002; /* Above modals and tooltips */
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: flex-end;
        }
        .toast {
            padding: 10px 15px;
            border-radius: var(--toast-border-radius);
            font-size: 0.9em;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            opacity: 0;
            transform: translateY(-20px);
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
            min-width: 200px;
            max-width: 300px;
            text-align: center;
        }
        .toast.show {
            opacity: 1;
            transform: translateY(0);
        }
        .toast.success {
            background-color: var(--toast-success-bg);
            color: var(--toast-success-color);
            border: 1px solid var(--green);
        }
        .toast.error {
            background-color: var(--toast-error-bg);
            color: var(--toast-error-color);
            border: 1px solid var(--red);
        }

        /* JSON Tree View styles */
        .json-tree-view {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            padding: 15px;
            border-radius: 8px;
            background-color: var(--main-color);
            border: 1px solid var(--border-color);
            overflow: auto;
            max-height: 400px; /* Example max height for tree view */
        }
        body.dark-mode .json-tree-view {
            background-color: #1e1e1e;
        }

        .json-tree {
            list-style: none;
            padding-left: 0; /* No indent for root ul */
            margin: 0;
        }
        .json-tree ul {
            list-style: none;
            padding-left: 1.5em; /* Indent children */
            margin: 0;
            display: block;
        }
        .json-tree li {
            position: relative;
            padding-left: 0; /* Remove default padding */
        }
        .json-tree li.collapsed > ul {
            display: none;
        }
        
        .json-tree ul {
            transition: all 0.3s ease;
        }
        
        /* Better spacing for tree items */
        .json-tree li {
            margin: 2px 0;
            line-height: 1.6;
        }
        
        /* Styling for collapsed/expanded indicators */
        .json-tree .tree-toggle:before {
            content: '';
            display: inline-block;
            width: 0;
            height: 0;
            margin-right: 6px;
            vertical-align: middle;
            border-left: 6px solid var(--text-color);
            border-top: 4px solid transparent;
            border-bottom: 4px solid transparent;
            transition: transform 0.2s ease;
        }
        
        .json-tree li.collapsed .tree-toggle:before {
            transform: rotate(-90deg);
        }
        .json-tree .tree-toggle {
            cursor: pointer;
            display: inline-block;
            width: 1.2em;
            text-align: center;
            user-select: none;
            /* Using CSS variables for color */
            color: var(--text-color); 
        }
        .json-tree .tree-toggle:hover {
            color: var(--accent-color);
        }
        .json-tree .json-key { color: var(--json-key); }
        .json-tree .json-string { color: var(--json-string); }
        .json-tree .json-number { color: var(--json-number); }
        .json-tree .json-boolean { color: var(--json-boolean); }
        .json-tree .json-null { color: var(--json-null); }
        .json-tree .json-bracket { 
            color: var(--json-bracket); 
            font-weight: 500;
            opacity: 0.8;
        }
        .json-tree .json-comma { color: var(--json-comma); }
        .json-tree .json-colon { color: var(--json-colon); }
        
        /* Array index styling - using attribute selector for better compatibility */
        .json-tree .array-index { 
            color: var(--orange); 
            font-weight: 600;
            font-style: italic;
        }

        /* Schema validation result styling */
        .schema-success {
            background-color: rgba(40, 167, 69, 0.1);
            border-left: 4px solid var(--green);
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }

        .schema-error {
            background-color: rgba(220, 53, 69, 0.1);
            border-left: 4px solid var(--red);
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }

        /* Schema examples styling */
        .schema-examples details {
            margin-top: 8px;
        }

        .schema-examples details[open] {
            background-color: var(--bg-color);
            border-radius: 6px;
            padding: 8px;
        }

        .schema-examples summary {
            font-weight: 500;
            color: var(--accent-color);
        }

        .schema-examples summary:hover {
            opacity: 0.8;
        }

        .schema-examples pre {
            background: var(--main-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 8px;
            overflow-x: auto;
        }

        /* Schema validation specific error types */
        .error-type-SchemaRequiredError {
            border-left-color: #e74c3c;
        }

        .error-type-SchemaTypeError {
            border-left-color: #f39c12;
        }

        .error-type-SchemaFormatError {
            border-left-color: #9b59b6;
        }

        .error-type-SchemaRangeError {
            border-left-color: #e67e22;
        }

        /* Dark mode adjustments */
        body.dark-mode .schema-success {
            background-color: rgba(40, 167, 69, 0.15);
        }

        body.dark-mode .schema-error {
            background-color: rgba(220, 53, 69, 0.15);
        }

        /* Diff highlighting in tree view */
        .json-tree .diff-added-text { background-color: rgba(40, 167, 69, 0.2); }
        .json-tree .diff-removed-text { background-color: rgba(220, 53, 69, 0.2); }
        .json-tree .diff-changed-text { background-color: rgba(0, 123, 255, 0.2); }

        body.dark-mode .json-tree .diff-added-text { background-color: rgba(40, 167, 69, 0.3); }
        body.dark-mode .json-tree .diff-removed-text { background-color: rgba(220, 53, 69, 0.3); }
        body.dark-mode .json-tree .diff-changed-text { background-color: rgba(0, 123, 255, 0.3); }

        /* Accessibility improvements */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Skip navigation */
        .skip-link {
            position: absolute;
            top: -40px;
            left: 6px;
            background: var(--accent-color);
            color: white;
            padding: 8px;
            text-decoration: none;
            z-index: 100;
            border-radius: 4px;
        }
        .skip-link:focus {
            top: 6px;
        }

        /* Focus improvements */
        *:focus {
            outline: 2px solid var(--accent-color);
            outline-offset: 2px;
        }

        /* High contrast improvements */
        @media (prefers-contrast: high) {
            :root {
                --border-color: #000;
                --text-color: #000;
                --bg-color: #fff;
            }
            body.dark-mode {
                --border-color: #fff;
                --text-color: #fff;
                --bg-color: #000;
            }
        }

        /* Reduced motion support */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Live region for announcements */
        #live-region {
            position: absolute;
            left: -10000px;
            width: 1px;
            height: 1px;
            overflow: hidden;
        }

        /* Scroll to top button */
        #scrollToTopBtn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background-color: var(--accent-color);
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.5em;
            font-weight: bold;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transform: translateY(20px);
        }

        #scrollToTopBtn.show {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        #scrollToTopBtn:hover {
            background-color: #0056b3;
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
        }

        #scrollToTopBtn:active {
            transform: translateY(0);
        }

        body.dark-mode #scrollToTopBtn {
            background-color: #0056b3;
            box-shadow: 0 4px 12px rgba(255, 255, 255, 0.1);
        }

        body.dark-mode #scrollToTopBtn:hover {
            background-color: #004494;
        }

        /* === VISUAL ENHANCEMENTS & ANALYTICS === */
        
        /* Minimap Navigation */
        .minimap-container {
            position: sticky;
            top: 20px;
            width: 200px;
            max-height: 400px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
            margin-left: 15px;
            overflow-y: auto;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            z-index: 100;
        }

        .minimap-header {
            font-size: 12px;
            font-weight: bold;
            color: var(--accent-color);
            margin-bottom: 8px;
            text-align: center;
        }

        .minimap-item {
            padding: 2px 6px;
            margin: 1px 0;
            border-radius: 3px;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            border-left: 3px solid transparent;
        }

        .minimap-item:hover {
            background: var(--hover-color);
            transform: translateX(2px);
        }

        .minimap-item.added { border-left-color: var(--color-added); background: rgba(40, 167, 69, 0.1); }
        .minimap-item.removed { border-left-color: var(--color-removed); background: rgba(220, 53, 69, 0.1); }
        .minimap-item.changed { border-left-color: var(--color-changed); background: rgba(255, 193, 7, 0.1); }
        .minimap-item.schema-error { border-left-color: var(--color-error); background: rgba(220, 53, 69, 0.15); }

        .minimap-path {
            display: block;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
        }

        /* Enhanced Diff Display */
        .diff-panel {
            position: relative;
            margin-bottom: 20px;
        }

        .diff-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: var(--bg-secondary);
            border-radius: 6px 6px 0 0;
            border-bottom: 1px solid var(--border-color);
        }

        .diff-title {
            font-weight: bold;
            font-size: 14px;
        }

        .diff-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .view-toggle {
            display: flex;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            overflow: hidden;
        }

        .view-toggle button {
            padding: 4px 8px;
            border: none;
            background: var(--bg-color);
            color: var(--text-color);
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }

        .view-toggle button.active {
            background: var(--accent-color);
            color: white;
        }

        .view-toggle button:hover:not(.active) {
            background: var(--hover-color);
        }

        /* Inline Diff Highlighting */
        .inline-diff {
            font-family: 'Courier New', monospace;
            line-height: 1.6;
            white-space: pre-wrap;
            word-break: break-all;
        }

        .char-added {
            background: rgba(40, 167, 69, 0.3);
            color: #155724;
            padding: 0 1px;
        }

        .char-removed {
            background: rgba(220, 53, 69, 0.3);
            color: #721c24;
            text-decoration: line-through;
            padding: 0 1px;
        }

        .char-unchanged {
            opacity: 0.7;
        }

        /* Importance-based Color Coding */
        .importance-critical { border-left: 4px solid #dc3545; background: rgba(220, 53, 69, 0.05); }
        .importance-high { border-left: 4px solid #fd7e14; background: rgba(253, 126, 20, 0.05); }
        .importance-medium { border-left: 4px solid #ffc107; background: rgba(255, 193, 7, 0.05); }
        .importance-low { border-left: 4px solid #6c757d; background: rgba(108, 117, 125, 0.05); }

        /* Grouped Diff View */
        .grouped-diff {
            margin: 15px 0;
        }

        .diff-group {
            margin-bottom: 20px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
        }

        .group-header {
            background: var(--bg-secondary);
            padding: 10px 15px;
            border-bottom: 1px solid var(--border-color);
            font-weight: bold;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .group-header:hover {
            background: var(--hover-color);
        }

        .group-count {
            background: var(--accent-color);
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: normal;
        }

        .group-content {
            max-height: 300px;
            overflow-y: auto;
        }

        .group-content.collapsed {
            display: none;
        }

        /* Analytics Dashboard */
        .analytics-dashboard {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            border: 1px solid var(--border-color);
        }

        .analytics-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .analytics-title {
            font-size: 18px;
            font-weight: bold;
            color: var(--accent-color);
        }

        .analytics-export {
            display: flex;
            gap: 8px;
        }

        .analytics-export button {
            padding: 6px 12px;
            border: 1px solid var(--border-color);
            background: var(--bg-color);
            color: var(--text-color);
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }

        .analytics-export button:hover {
            background: var(--hover-color);
            border-color: var(--accent-color);
        }

        .analytics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .analytics-card {
            background: var(--bg-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
        }

        .card-title {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 10px;
            color: var(--text-color);
        }

        .chart-container {
            position: relative;
            height: 200px;
            margin: 10px 0;
        }

        .chart-container canvas {
            max-height: 100%;
        }

        /* Heatmap Styles */
        .heatmap-container {
            display: grid;
            gap: 2px;
            margin: 10px 0;
        }

        .heatmap-cell {
            aspect-ratio: 1;
            border-radius: 2px;
            position: relative;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .heatmap-cell:hover {
            transform: scale(1.1);
            z-index: 10;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .heatmap-cell.intensity-0 { background: var(--bg-secondary); }
        .heatmap-cell.intensity-1 { background: rgba(40, 167, 69, 0.2); }
        .heatmap-cell.intensity-2 { background: rgba(40, 167, 69, 0.4); }
        .heatmap-cell.intensity-3 { background: rgba(40, 167, 69, 0.6); }
        .heatmap-cell.intensity-4 { background: rgba(40, 167, 69, 0.8); }
        .heatmap-cell.intensity-5 { background: rgba(40, 167, 69, 1.0); }

        /* Timeline Styles */
        .timeline-container {
            margin: 15px 0;
        }

        .timeline-track {
            position: relative;
            height: 60px;
            background: var(--bg-secondary);
            border-radius: 6px;
            margin: 10px 0;
            overflow: hidden;
        }

        .timeline-item {
            position: absolute;
            top: 10px;
            height: 40px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            color: white;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        .timeline-item:hover {
            transform: scaleY(1.1);
            z-index: 10;
        }

        .timeline-item.added { background: var(--color-added); }
        .timeline-item.removed { background: var(--color-removed); }
        .timeline-item.changed { background: var(--color-changed); }

        /* Responsive adjustments for analytics */
        @media (max-width: 768px) {
            .analytics-grid {
                grid-template-columns: 1fr;
            }
            
            .minimap-container {
                position: relative;
                width: 100%;
                margin: 10px 0;
            }
            
            .diff-header {
                flex-direction: column;
                gap: 8px;
                align-items: stretch;
            }
        }

        /* Additional styles for enhanced diff display */
        .highlighted-row {
            background: rgba(255, 193, 7, 0.3) !important;
            transform: scale(1.01);
            box-shadow: 0 2px 8px rgba(255, 193, 7, 0.4);
            transition: all 0.3s ease;
        }

        .metrics-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .metric-item {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid var(--border-color);
        }

        .metric-item:last-child {
            border-bottom: none;
        }

        .metric-label {
            font-weight: 500;
            color: var(--text-color);
        }

        .metric-value {
            font-weight: bold;
            color: var(--accent-color);
        }

        .diff-item {
            padding: 12px;
            margin: 8px 0;
            border-radius: 6px;
            border-left: 4px solid transparent;
        }

        .diff-path {
            font-size: 12px;
            margin-bottom: 4px;
            font-weight: bold;
        }

        .diff-reason {
            font-size: 13px;
            margin-bottom: 8px;
            color: var(--text-color);
        }

        .diff-values {
            display: flex;
            flex-direction: column;
            gap: 4px;
            font-size: 11px;
        }

        .old-value, .new-value {
            padding: 4px 8px;
            border-radius: 4px;
            background: var(--bg-secondary);
        }

        /* Results layout with minimap */
        .results-layout {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }

        .results-main {
            flex: 1;
            min-width: 0;
        }

        .results-sidebar {
            flex-shrink: 0;
        }

        /* Tree view styles */
        .json-tree-view {
            background: var(--bg-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
        }

        .tree-node {
            margin: 2px 0;
        }

        .tree-node-header {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tree-node-header:hover {
            background: var(--hover-color);
        }

        .tree-node-normal { color: var(--text-color); }
        .tree-node-added { 
            background: rgba(40, 167, 69, 0.1); 
            border-left: 3px solid var(--color-added); 
        }
        .tree-node-removed { 
            background: rgba(220, 53, 69, 0.1); 
            border-left: 3px solid var(--color-removed); 
        }
        .tree-node-changed { 
            background: rgba(255, 193, 7, 0.1); 
            border-left: 3px solid var(--color-changed); 
        }
        .tree-node-schema-error { 
            background: rgba(220, 53, 69, 0.15); 
            border-left: 3px solid var(--color-error); 
        }

        .tree-toggle {
            font-family: monospace;
            font-size: 12px;
            cursor: pointer;
            user-select: none;
            width: 12px;
            text-align: center;
        }

        .tree-spacer {
            width: 12px;
            text-align: center;
            font-size: 8px;
            opacity: 0.5;
        }

        .tree-key {
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }

        .tree-diff-count {
            background: var(--accent-color);
            color: white;
            font-size: 10px;
            padding: 1px 6px;
            border-radius: 8px;
            margin-left: auto;
        }

        .tree-node-content {
            margin-left: 18px;
            border-left: 1px dotted var(--border-color);
            padding-left: 10px;
        }

        .tree-node-content.collapsed {
            display: none;
        }

        .tree-diff-item {
            padding: 6px 10px;
            margin: 4px 0;
            border-radius: 4px;
            font-size: 12px;
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .diff-type {
            background: var(--bg-secondary);
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: bold;
            font-size: 10px;
            min-width: 60px;
            text-align: center;
        }

        .diff-reason {
            flex: 1;
            color: var(--text-color);
        }

        /* Sync scroll between diff panels */
        .diff-sync-scroll {
            overflow-y: auto;
            max-height: 400px;
        }

        .diff-sync-scroll::-webkit-scrollbar {
            width: 8px;
        }

        .diff-sync-scroll::-webkit-scrollbar-track {
            background: var(--bg-secondary);
            border-radius: 4px;
        }

        .diff-sync-scroll::-webkit-scrollbar-thumb {
            background: var(--accent-color);
            border-radius: 4px;
        }

        .diff-sync-scroll::-webkit-scrollbar-thumb:hover {
            background: #0056b3;
        }
    </style>
  </head>
<body>
    <!-- Skip Navigation -->
    <a href="#main-content" class="skip-link">–ü–µ—Ä–µ–π—Ç–∏ –¥–æ –æ—Å–Ω–æ–≤–Ω–æ–≥–æ –≤–º—ñ—Å—Ç—É</a>
    <a href="#results" class="skip-link">–ü–µ—Ä–µ–π—Ç–∏ –¥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤</a>
    
    <!-- Live region for screen reader announcements -->
    <div id="live-region" aria-live="polite" aria-atomic="true"></div>
    
    <!-- Scroll to top button -->
    <div class="tooltip-container">
        <button id="scrollToTopBtn" aria-label="–ü–æ–≤–µ—Ä–Ω—É—Ç–∏—Å—è –¥–æ –ø–æ—á–∞—Ç–∫—É —Å—Ç–æ—Ä—ñ–Ω–∫–∏">
            ‚Üë
        </button>
        <span class="tooltip">–ü–æ–≤–µ—Ä–Ω—É—Ç–∏—Å—è –¥–æ –ø–æ—á–∞—Ç–∫—É —Å—Ç–æ—Ä—ñ–Ω–∫–∏</span>
    </div>
    
    <div id="app-content">
        <div id="loader"><div class="loader-spinner"></div></div>
        <div id="settingsModal" class="modal-overlay">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>‚öôÔ∏è –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è</h2>
                    <button class="modal-close" id="closeSettingsModal" aria-label="–ó–∞–∫—Ä–∏—Ç–∏ –≤—ñ–∫–Ω–æ">&times;</button>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label for="ignorePaths" class="tooltip-container">
                            –ü–æ–ª—è –¥–ª—è —ñ–≥–Ω–æ—Ä—É–≤–∞–Ω–Ω—è (JSONPath)
                            <span class="tooltip">
                                –í–∫–∞–∂—ñ—Ç—å —à–ª—è—Ö–∏ –¥–æ –ø–æ–ª—ñ–≤, —è–∫—ñ –ø–æ—Ç—Ä—ñ–±–Ω–æ —ñ–≥–Ω–æ—Ä—É–≤–∞—Ç–∏.<br>
                                –ö–æ–∂–µ–Ω —à–ª—è—Ö –∑ –Ω–æ–≤–æ–≥–æ —Ä—è–¥–∫–∞.<br>
                                –ù–∞–ø—Ä–∏–∫–ª–∞–¥: `$.updatedAt` –∞–±–æ `$.items[*].timestamp`
                            </span>
                        </label>
                        <textarea id="ignorePaths" placeholder="$.timestamp&#10;$.user.lastLogin"></textarea>
                    </div>
                    <div class="form-group">
                        <label class="tooltip-container">
                            –†–µ–∂–∏–º –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è –º–∞—Å–∏–≤—ñ–≤
                            <span class="tooltip">
                                "–†–æ–∑—É–º–Ω–∏–π" —Ä–µ–∂–∏–º: —à—É–∫–∞—î –æ–±'—î–∫—Ç–∏ –≤ –º–∞—Å–∏–≤–∞—Ö –∑–∞ –∫–ª—é—á–µ–º (id, name), —ñ–¥–µ–∞–ª—å–Ω–æ –¥–ª—è –Ω–µ–≤–ø–æ—Ä—è–¥–∫–æ–≤–∞–Ω–∏—Ö —Å–ø–∏—Å–∫—ñ–≤.<br>
                                "–ü—Ä–æ—Å—Ç–∏–π" —Ä–µ–∂–∏–º –ø–æ—Ä—ñ–≤–Ω—é—î –µ–ª–µ–º–µ–Ω—Ç–∏ –º–∞—Å–∏–≤—ñ–≤ –∑–∞ —ó—Ö–Ω—å–æ—é –ø–æ–∑–∏—Ü—ñ—î—é (—ñ–Ω–¥–µ–∫—Å–æ–º), —â–æ –ø—ñ–¥—Ö–æ–¥–∏—Ç—å –¥–ª—è –≤–ø–æ—Ä—è–¥–∫–æ–≤–∞–Ω–∏—Ö —Å–ø–∏—Å–∫—ñ–≤.
                            </span>
                        </label>
                        <div class="radio-group">
                            <input type="radio" id="arrayModeKey" name="arrayCompareMode" value="key" checked>
                            <label for="arrayModeKey">–†–æ–∑—É–º–Ω–∏–π (–∑–∞ –∫–ª—é—á–µ–º)</label>
                            <input type="radio" id="arrayModeIndex" name="arrayCompareMode" value="index">
                            <label for="arrayModeIndex">–ü—Ä–æ—Å—Ç–∏–π (–∑–∞ —ñ–Ω–¥–µ–∫—Å–æ–º)</label>
                        </div>
                    </div>
                    <div class="form-group">
                        <div class="checkbox-group">
                            <input type="checkbox" id="caseSensitive">
                            <label for="caseSensitive" class="tooltip-container">
                                –í—Ä–∞—Ö–æ–≤—É–≤–∞—Ç–∏ —Ä–µ–≥—ñ—Å—Ç—Ä —Å–∏–º–≤–æ–ª—ñ–≤
                                <span class="tooltip">
                                    –Ø–∫—â–æ –≤–∏–º–∫–Ω–µ–Ω–æ, "Text" —Ç–∞ "text" –±—É–¥—É—Ç—å –≤–≤–∞–∂–∞—Ç–∏—Å—è –æ–¥–Ω–∞–∫–æ–≤–∏–º–∏.
                                </span>
                            </label>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button id="saveSettingsBtn" class="action-btn">–ó–±–µ—Ä–µ–≥—Ç–∏</button>
                </div>
            </div>
        </div>

        <div class="container" id="main-container">
            <main id="main-content">
            <div class="header">
                 <div class="top-controls">
                    <span class="tooltip-container">
                        <button id="widthToggleBtn" aria-label="–ü–µ—Ä–µ–º–∫–Ω—É—Ç–∏ —à–∏—Ä–∏–Ω—É">
                            <svg id="width-enter-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 3h6v6M9 21H3v-6M21 3l-7 7M3 21l7-7"/></svg>
                            <svg id="width-exit-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;"><path d="M9 3h6v6M15 21H9v-6M3 9V3h6M21 15v6h-6"/></svg>
                        </button>
                        <span class="tooltip">–ü–µ—Ä–µ–º–∫–Ω—É—Ç–∏ —à–∏—Ä–∏–Ω—É —Ä–æ–±–æ—á–æ—ó –æ–±–ª–∞—Å—Ç—ñ</span>
                    </span>
                    <div class="theme-switch-wrapper tooltip-container">
                        <label class="theme-switch" for="checkbox">
                            <input type="checkbox" id="checkbox" aria-label="–ü–µ—Ä–µ–º–∫–Ω—É—Ç–∏ —Ç–µ–º–Ω—É —Ç–µ–º—É" />
                            <div class="slider round"></div>
                        </label>
                        <span class="tooltip">–ü–µ—Ä–µ–º–∫–Ω—É—Ç–∏ —Å–≤—ñ—Ç–ª—É/—Ç–µ–º–Ω—É —Ç–µ–º—É</span>
                    </div>
                    <span class="tooltip-container">
                        <button id="settingsBtn" aria-label="–†–æ–∑—à–∏—Ä–µ–Ω—ñ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è">‚öôÔ∏è</button>
                        <span class="tooltip">–í—ñ–¥–∫—Ä–∏—Ç–∏ —Ä–æ–∑—à–∏—Ä–µ–Ω—ñ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è</span>
                    </span>
                </div>
                <h1>–Ü–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–∏–π JSON Comparator</h1>
                <p>–ü–æ—Ä—ñ–≤–Ω—é–π—Ç–µ —Ñ–∞–π–ª–∏ —Ç–∞ –ø–µ—Ä–µ–≤—ñ—Ä—è–π—Ç–µ —Å—Ö–µ–º–∏</p>
            </div>

            <div class="mode-selector" role="radiogroup" aria-labelledby="mode-selector-label">
                <span id="mode-selector-label" class="sr-only">–û–±–µ—Ä—ñ—Ç—å —Ä–µ–∂–∏–º –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è</span>
                <input type="radio" id="modeDirect" name="compareMode" value="direct" checked aria-describedby="modeDirect-desc">
                <div class="tooltip-container">
                    <label for="modeDirect">–ü—Ä—è–º–µ –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è</label>
                    <span class="tooltip">–ü–æ—Ä—ñ–≤–Ω—é—î –≤—Å—ñ –ø–æ–ª—è —Ç–∞ –∑–Ω–∞—á–µ–Ω–Ω—è –º—ñ–∂ –¥–≤–æ–º–∞ JSON —Ñ–∞–π–ª–∞–º–∏.<br/>–ü–æ–∫–∞–∑—É—î –≤—Å—ñ –≤—ñ–¥–º—ñ–Ω–Ω–æ—Å—Ç—ñ: –¥–æ–¥–∞–Ω—ñ, –≤–∏–¥–∞–ª–µ–Ω—ñ —Ç–∞ –∑–º—ñ–Ω–µ–Ω—ñ –µ–ª–µ–º–µ–Ω—Ç–∏.<br/><strong>–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ –¥–ª—è:</strong> –ø–æ–≤–Ω–æ–≥–æ –∞–Ω–∞–ª—ñ–∑—É –≤—ñ–¥–º—ñ–Ω–Ω–æ—Å—Ç–µ–π.</span>
                </div>
                <span id="modeDirect-desc" class="sr-only">–ü–æ—Ä—ñ–≤–Ω—é—î –≤—Å—ñ –∑–Ω–∞—á–µ–Ω–Ω—è —É JSON —Ñ–∞–π–ª–∞—Ö</span>
                
                <input type="radio" id="modeKeys" name="compareMode" value="keys" aria-describedby="modeKeys-desc">
                <div class="tooltip-container">
                    <label for="modeKeys">–õ–∏—à–µ –∫–ª—é—á—ñ</label>
                    <span class="tooltip">–ü–æ—Ä—ñ–≤–Ω—é—î —Ç—ñ–ª—å–∫–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—É —Ç–∞ –Ω–∞–∑–≤–∏ –∫–ª—é—á—ñ–≤, —ñ–≥–Ω–æ—Ä—É—é—á–∏ –∑–Ω–∞—á–µ–Ω–Ω—è.<br/>–ö–æ—Ä–∏—Å–Ω–æ –¥–ª—è –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ —Å—Ö–µ–º–∏ –±–µ–∑ –∞–Ω–∞–ª—ñ–∑—É –¥–∞–Ω–∏—Ö.<br/><strong>–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ –¥–ª—è:</strong> –≤–∞–ª—ñ–¥–∞—Ü—ñ—ó —Å—Ç—Ä—É–∫—Ç—É—Ä–∏ JSON.</span>
                </div>
                <span id="modeKeys-desc" class="sr-only">–ü–æ—Ä—ñ–≤–Ω—é—î —Ç—ñ–ª—å–∫–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—É –∫–ª—é—á—ñ–≤ –±–µ–∑ –∑–Ω–∞—á–µ–Ω—å</span>

                <input type="radio" id="modeSchema" name="compareMode" value="schema" aria-describedby="modeSchema-desc">
                <div class="tooltip-container">
                    <label for="modeSchema">–í–∞–ª—ñ–¥–∞—Ü—ñ—è —Å—Ö–µ–º–∏</label>
                    <span class="tooltip">–ü–µ—Ä–µ–≤—ñ—Ä—è—î JSON —Ñ–∞–π–ª –Ω–∞ –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω—ñ—Å—Ç—å JSON Schema.<br/>–í–∏—è–≤–ª—è—î –ø–æ—Ä—É—à–µ–Ω–Ω—è —Ç–∏–ø—ñ–≤ –¥–∞–Ω–∏—Ö, –æ–±–æ–≤'—è–∑–∫–æ–≤–∏—Ö –ø–æ–ª—ñ–≤ —Ç–∞ –æ–±–º–µ–∂–µ–Ω—å.<br/><strong>–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ –¥–ª—è:</strong> –≤–∞–ª—ñ–¥–∞—Ü—ñ—ó –¥–∞–Ω–∏—Ö –∑–∞ —Å—Ö–µ–º–æ—é.<br/><strong>–ü—ñ–¥—Ç—Ä–∏–º–∫–∞:</strong> AJV v8.17.1 + –¥–æ–¥–∞—Ç–∫–æ–≤—ñ —Ñ–æ—Ä–º–∞—Ç–∏ (email, date, uri, etc.)<br/><strong>–°—Ö–µ–º–∏:</strong> Draft 4, 6, 7, 2019-09, 2020-12</span>
                </div>
                <span id="modeSchema-desc" class="sr-only">–ü–µ—Ä–µ–≤—ñ—Ä—è—î JSON –Ω–∞ –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω—ñ—Å—Ç—å —Å—Ö–µ–º—ñ</span>
            </div>

            <div class="drop-zones">
                <div id="dropZone1" class="drop-zone" role="region" aria-labelledby="dropZone1-label" aria-describedby="dropZone1-desc">
                    <label id="dropZone1-label" for="sourceText" class="sr-only">Source JSON —Ñ–∞–π–ª</label>
                    <span id="dropZone1-desc" class="sr-only">–ü–µ—Ä–µ—Ç—è–≥–Ω—ñ—Ç—å JSON —Ñ–∞–π–ª –∞–±–æ –≤—Å—Ç–∞–≤—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è —è–∫ –¥–∂–µ—Ä–µ–ª–æ</span>
                    <textarea id="sourceText" placeholder="–ü–µ—Ä–µ—Ç—è–≥–Ω—ñ—Ç—å —Å—é–¥–∏ Source —Ñ–∞–π–ª –∞–±–æ –≤—Å—Ç–∞–≤—Ç–µ JSON" 
                              aria-labelledby="dropZone1-label" aria-describedby="dropZone1-desc sourceError"
                              aria-invalid="false"></textarea>
                    <div class="error-message" id="sourceError" role="alert" aria-live="polite"></div>
                    <span class="file-name" id="fileName1" aria-live="polite"></span>
                </div>
                <div id="dropZone2" class="drop-zone" role="region" aria-labelledby="dropZone2-label" aria-describedby="dropZone2-desc">
                    <label id="dropZone2-label" for="targetText" class="sr-only">Target JSON —Ñ–∞–π–ª</label>
                    <span id="dropZone2-desc" class="sr-only">–ü–µ—Ä–µ—Ç—è–≥–Ω—ñ—Ç—å JSON —Ñ–∞–π–ª –∞–±–æ –≤—Å—Ç–∞–≤—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è —è–∫ —Ü—ñ–ª—å</span>
                    <textarea id="targetText" placeholder="–ü–µ—Ä–µ—Ç—è–≥–Ω—ñ—Ç—å —Å—é–¥–∏ Target —Ñ–∞–π–ª –∞–±–æ –≤—Å—Ç–∞–≤—Ç–µ JSON"
                              aria-labelledby="dropZone2-label" aria-describedby="dropZone2-desc targetError"
                              aria-invalid="false"></textarea>
                    <div class="error-message" id="targetError" role="alert" aria-live="polite"></div>
                    <span class="file-name" id="fileName2" aria-live="polite"></span>
                </div>
                <div id="dropZoneSchema" class="drop-zone hidden" role="region" aria-labelledby="dropZoneSchema-label" aria-describedby="dropZoneSchema-desc">
                    <label id="dropZoneSchema-label" for="schemaText" class="sr-only">JSON Schema —Ñ–∞–π–ª</label>
                    <span id="dropZoneSchema-desc" class="sr-only">–ü–µ—Ä–µ—Ç—è–≥–Ω—ñ—Ç—å JSON Schema —Ñ–∞–π–ª –∞–±–æ –≤—Å—Ç–∞–≤—Ç–µ —Å—Ö–µ–º—É –¥–ª—è –≤–∞–ª—ñ–¥–∞—Ü—ñ—ó</span>
                                    <textarea id="schemaText" placeholder="–ü–µ—Ä–µ—Ç—è–≥–Ω—ñ—Ç—å —Å—é–¥–∏ JSON Schema —Ñ–∞–π–ª –∞–±–æ –≤—Å—Ç–∞–≤—Ç–µ —Å—Ö–µ–º—É"
                          aria-labelledby="dropZoneSchema-label" aria-describedby="dropZoneSchema-desc schemaError"
                          aria-invalid="false"></textarea>
                <div class="schema-examples" style="margin-top: 10px; font-size: 0.9em; color: var(--text-color); opacity: 0.7;">
                    <details>
                        <summary style="cursor: pointer; margin-bottom: 5px;">üìã –ü—Ä–∏–∫–ª–∞–¥–∏ JSON Schema</summary>
                        <div style="background: var(--bg-color); padding: 10px; border-radius: 4px; margin-top: 5px;">
                            <strong>–ë–∞–∑–æ–≤–∞ —Å—Ö–µ–º–∞ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞:</strong>
                            <button id="insertExampleSchema" style="float: right; background: var(--accent-color); color: white; border: none; padding: 4px 8px; border-radius: 4px; font-size: 0.8em; cursor: pointer;" title="–í—Å—Ç–∞–≤–∏—Ç–∏ —Ü—é —Å—Ö–µ–º—É">üìã –í—Å—Ç–∞–≤–∏—Ç–∏</button>
                            <pre id="exampleSchemaText" style="font-size: 0.8em; margin: 5px 0; white-space: pre-wrap; clear: both;">{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "required": ["name", "email", "age"],
  "properties": {
    "name": { "type": "string", "minLength": 1 },
    "email": { "type": "string", "format": "email" },
    "age": { "type": "integer", "minimum": 0, "maximum": 150 },
    "phone": { "type": "string", "pattern": "^\\+?[1-9]\\d{1,14}$" }
  },
  "additionalProperties": false
}</pre>
                        </div>
                    </details>
                </div>
                    <div class="error-message" id="schemaError" role="alert" aria-live="polite"></div>
                    <span class="file-name" id="fileNameSchema" aria-live="polite"></span>
                </div>
            </div>

            <div class="controls">
                <span class="tooltip-container">
                    <button id="compareBtn" class="action-btn" disabled>–ü–æ—Ä—ñ–≤–Ω—è—Ç–∏</button>
                    <span class="tooltip">–†–æ–∑–ø–æ—á–∞—Ç–∏ –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è –∞–±–æ –≤–∞–ª—ñ–¥–∞—Ü—ñ—é —Ñ–∞–π–ª—ñ–≤</span>
                </span>
                
                <div class="export-container tooltip-container">
                    <button id="exportBtn" class="action-btn" style="display:none;">üíæ –ï–∫—Å–ø–æ—Ä—Ç</button>
                    <span class="tooltip">–ó–±–µ—Ä–µ–≥—Ç–∏ –∑–≤—ñ—Ç –ø—Ä–æ –≤—ñ–¥–º—ñ–Ω–Ω–æ—Å—Ç—ñ —É —Ä—ñ–∑–Ω–∏—Ö —Ñ–æ—Ä–º–∞—Ç–∞—Ö</span>
                    <div class="export-dropdown">
                        <a href="#" id="exportTxt">–¢–µ–∫—Å—Ç–æ–≤–∏–π –∑–≤—ñ—Ç (.txt)</a>
                        <a href="#" id="exportJson">JSON –∑–≤—ñ—Ç (.json)</a>
                        <a href="#" id="exportCsv">CSV –∑–≤—ñ—Ç (.csv)</a>
                    </div>
                </div>
                <span class="tooltip-container">
                    <button id="clearAllBtn" class="action-btn">–û—á–∏—Å—Ç–∏—Ç–∏</button>
                    <span class="tooltip">–û—á–∏—Å—Ç–∏—Ç–∏ –≤—Å—ñ –≤—Ö—ñ–¥–Ω—ñ –ø–æ–ª—è —Ç–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏</span>
                </span>
                <span class="tooltip-container">
                    <button id="copyResultsBtn" class="action-btn" style="display:none;">–ö–æ–ø—ñ—é–≤–∞—Ç–∏</button>
                    <span class="tooltip">–°–∫–æ–ø—ñ—é–≤–∞—Ç–∏ –ø–æ—Ç–æ—á–Ω–∏–π –∑–≤—ñ—Ç –¥–æ –±—É—Ñ–µ—Ä–∞ –æ–±–º—ñ–Ω—É (CSV —Ñ–æ—Ä–º–∞—Ç)</span>
                </span>
            </div>

                            <div id="results" role="region" aria-labelledby="results-heading">
                </div>
            </main>
        </div>
    </div>

    <div id="toast-container"></div>
    
    <script>
        // --- Global Helper Functions (moved outside DOMContentLoaded for wider scope) ---

        // Toast Notifications
        const toastContainer = document.createElement('div');
        toastContainer.id = 'toast-container';
        document.body.appendChild(toastContainer); // Append toast container early
        function showToast(message, type = 'info', duration = 3000) {
            try {
                const toast = document.createElement('div');
                toast.classList.add('toast', type);
                toast.textContent = message;
                
                if (toastContainer && toastContainer.appendChild) {
                    toastContainer.appendChild(toast);
                } else {
                    console.warn('Toast container not available');
                    return;
                }

                void toast.offsetWidth; // Force reflow
                toast.classList.add('show');

                setTimeout(() => {
                    toast.classList.remove('show');
                    toast.addEventListener('transitionend', () => toast.remove());
                }, duration);
            } catch (e) {
                console.error('Error showing toast:', e);
                // Fallback to console log
                console.log(`[${type.toUpperCase()}] ${message}`);
            }
        }

        // Enhanced HTML escaping for better XSS protection
        function escapeHtml(text) {
            if (text === null || text === undefined) {
                return '';
            }
            
            const str = String(text);
            const map = { 
                '&': '&amp;', 
                '<': '&lt;', 
                '>': '&gt;', 
                '"': '&quot;', 
                "'": '&#x27;',
                '/': '&#x2F;',
                '`': '&#x60;',
                '=': '&#x3D;'
            };
            
            return str.replace(/[&<>"'`=\/]/g, m => map[m]);
        }

        // Additional sanitization for user input
        function sanitizeInput(input) {
            if (typeof input !== 'string') return input;
            
            // Remove potentially dangerous patterns
            const dangerous = [
                /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
                /<iframe\b[^<]*(?:(?!<\/iframe>)<[^<]*)*<\/iframe>/gi,
                /javascript:/gi,
                /on\w+\s*=/gi,
                /data:text\/html/gi
            ];
            
            let sanitized = input;
            dangerous.forEach(pattern => {
                sanitized = sanitized.replace(pattern, '');
            });
            
            return sanitized;
        }

        // Validate file type and content
        function validateFileContent(content, filename) {
            // Check file extension
            const allowedExtensions = ['.json', '.txt'];
            const extension = filename.toLowerCase().substring(filename.lastIndexOf('.'));
            
            if (!allowedExtensions.includes(extension)) {
                throw new Error(`–ù–µ–ø—ñ–¥—Ç—Ä–∏–º—É–≤–∞–Ω–∏–π —Ç–∏–ø —Ñ–∞–π–ª—É: ${extension}. –î–æ–∑–≤–æ–ª–µ–Ω—ñ: ${allowedExtensions.join(', ')}`);
            }
            
            // Basic content validation
            if (typeof content !== 'string') {
                throw new Error('–í–º—ñ—Å—Ç —Ñ–∞–π–ª—É –ø–æ–≤–∏–Ω–µ–Ω –±—É—Ç–∏ —Ç–µ–∫—Å—Ç–æ–≤–∏–º');
            }
            
            // Check for suspicious content
            const suspiciousPatterns = [
                /<script/i,
                /javascript:/i,
                /<iframe/i,
                /data:text\/html/i,
                /vbscript:/i
            ];
            
            for (const pattern of suspiciousPatterns) {
                if (pattern.test(content)) {
                    throw new Error('–§–∞–π–ª –º—ñ—Å—Ç–∏—Ç—å –ø–æ—Ç–µ–Ω—Ü—ñ–π–Ω–æ –Ω–µ–±–µ–∑–ø–µ—á–Ω–∏–π –≤–º—ñ—Å—Ç');
                }
            }
            
            return sanitizeInput(content);
        }

        // Helper for JSON syntax highlighting (used in both code and tree views)
        function applySyntaxHighlighting(value) {
            let formattedValue;
            if (typeof value === 'string') {
                formattedValue = `<span class="json-string">${escapeHtml(JSON.stringify(value))}</span>`; // Keep quotes, escape HTML
            } else if (typeof value === 'number') {
                formattedValue = `<span class="json-number">${value}</span>`;
            } else if (typeof value === 'boolean') {
                formattedValue = `<span class="json-boolean">${value}</span>`;
            } else if (value === null) {
                formattedValue = `<span class="json-null">null</span>`;
            } else {
                formattedValue = escapeHtml(String(value)); // Fallback, should not typically happen for primitives
            }
            return formattedValue;
        }

        // Helper to determine the diff class for a given path (used by both code and tree views)
        function getLineClass(path, isKeyLine, diffMap, side) {
            let lineClass = '';
            const type = diffMap.get(path);

            if (type) {
                if (side === 'target' && type.includes('Added')) lineClass = 'diff-added-text';
                else if (side === 'source' && type.includes('Removed')) lineClass = 'diff-removed-text';
                else if (type.includes('Changed') || type.includes('Error')) lineClass = 'diff-changed-text';
            } else if (isKeyLine) {
                // If it's a key line (parent of a value), check for child diffs for broader highlighting
                for (const [diffPathFromMap, diffType] of diffMap.entries()) {
                    const diffPathStr = String(diffPathFromMap); // Ensure it's a string
                    if (diffPathStr.startsWith(path + '.') || diffPathStr.startsWith(path + '[')) {
                        if (side === 'target' && diffType.includes('Added')) { lineClass = 'diff-added-text'; break; }
                        if (side === 'source' && diffType.includes('Removed')) { lineClass = 'diff-removed-text'; break; }
                        if (diffType.includes('Changed') || diffType.includes('Error')) { lineClass = 'diff-changed-text'; break; }
                    }
                }
            }
            return lineClass;
        }

        // --- JSON Traverse and Render (for code view) ---
        function jsonTraverseAndRender(obj, diffs, side, currentPath = '$', indentLevel = 0) {
            const indentSpace = ' '.repeat(indentLevel * 2);
            let html = '';
            const diffMap = new Map(diffs.map(d => [d.path, d.type]));

            const formatAndHighlightLine = (contentHtml, path, isKeyLine = false) => {
                const lineClass = getLineClass(path, isKeyLine, diffMap, side);
                return `<span class="diff-line${lineClass ? ' ' + lineClass : ''}" data-path="${path}">${contentHtml}</span>`;
            };

            if (typeof obj !== 'object' || obj === null) {
                return formatAndHighlightLine(applySyntaxHighlighting(obj), currentPath);
            }

            if (Array.isArray(obj)) {
                html += formatAndHighlightLine(indentSpace + '<span class="json-bracket">[</span>', currentPath) + '\n';
                
                const potentialKeys = ['id', 'productId', 'variantId', 'reviewId', 'key', 'name'];
                const bestKey = potentialKeys.find(key => obj.every(item => item && typeof item === 'object' && item[key] !== undefined));

                for (let i = 0; i < obj.length; i++) {
                    const item = obj[i];
                    let itemPath = `${currentPath}[${i}]`;

                    if (bestKey && typeof item === 'object' && item !== null && item[bestKey] !== undefined) {
                        itemPath = `${currentPath}[${bestKey}=${JSON.stringify(item[bestKey])}]`;
                    }
                    
                    html += jsonTraverseAndRender(item, diffs, side, itemPath, indentLevel + 1);
                    
                    if (i < obj.length - 1) {
                        html += `<span class="json-comma">,</span>`;
                    }
                    html += `\n`;
                }
                html += formatAndHighlightLine(indentSpace + '<span class="json-bracket">]</span>', currentPath);
            } else { // Object
                html += formatAndHighlightLine(indentSpace + '<span class="json-bracket">{</span>', currentPath) + '\n';
                const keys = Object.keys(obj);

                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const propPath = `${currentPath}.${key}`;
                    const value = obj[key];
                    
                    const valueHtml = jsonTraverseAndRender(value, diffs, side, propPath, indentLevel + 1);
                    
                    const keyLineContent = `<span class="json-key">"${escapeHtml(key)}"</span><span class="json-colon">:</span> ${valueHtml}`;
                    
                    html += formatAndHighlightLine(keyLineContent, propPath, true);
                    if (i < keys.length - 1) {
                        html += `<span class="json-comma">,</span>`;
                    }
                    html += `</span>\n`; // Close span for the line and add newline
                }
                html += formatAndHighlightLine(indentSpace + '<span class="json-bracket">}</span>', currentPath);
            }
            return html;
        }

        // --- JSON Tree View Functions ---
        function createJsonTree(data, containerElement, diffs, side) {
            console.log('Creating JSON tree for:', { 
                data: data, 
                side: side, 
                diffsCount: diffs.length,
                containerElement: containerElement 
            });
            
            containerElement.innerHTML = ''; // Clear previous tree
            const ul = document.createElement('ul');
            ul.classList.add('json-tree');
            let diffMap = new Map(diffs.map(d => [d.path, d.type]));

            function buildTree(node, path, parentUl) {
                const li = document.createElement('li');
                li.dataset.path = path;

                let nodeClass = getLineClass(path, true, diffMap, side);
                if (nodeClass && nodeClass.trim()) {
                    li.classList.add(nodeClass);
                }

                if (typeof node === 'object' && node !== null) {
                    const isArray = Array.isArray(node);
                    const toggleSpan = document.createElement('span');
                    toggleSpan.classList.add('tree-toggle');
                    
                    if (path !== '$' && path.includes('.')) { // Object property
                        const key = path.substring(path.lastIndexOf('.') + 1);
                        toggleSpan.innerHTML = `<span class="json-key">"${escapeHtml(key)}"</span><span class="json-colon">:</span> `;
                    } else if (path !== '$' && path.includes('[')) { // Array item
                        // Show array index or key for array items
                        const indexMatch = path.match(/\[([^\]]+)\]$/);
                        if (indexMatch) {
                            const indexOrKey = indexMatch[1];
                            if (indexOrKey.includes('=')) {
                                // Key-based indexing like [id=123]
                                const [keyName, keyValue] = indexOrKey.split('=');
                                toggleSpan.innerHTML = `<span class="json-key array-index">[${keyName}: ${keyValue}]</span> `;
                            } else {
                                // Numeric index like [0]
                                toggleSpan.innerHTML = `<span class="json-key array-index">[${indexOrKey}]</span> `;
                            }
                        }
                    }

                    // Initial state of brackets for toggle - –ø–æ–∫–∞–∑—É—î–º–æ –∫—ñ–ª—å–∫—ñ—Å—Ç—å –µ–ª–µ–º–µ–Ω—Ç—ñ–≤ —É –∑–≥–æ—Ä–Ω—É—Ç–æ–º—É —Å—Ç–∞–Ω—ñ
                    const isCollapsed = path !== '$' ? true : false; // Root is expanded, others collapsed
                    
                    let bracketText;
                    if (isCollapsed) {
                        if (isArray) {
                            const itemText = node.length === 1 ? '–µ–ª–µ–º–µ–Ω—Ç' : (node.length < 5 ? '–µ–ª–µ–º–µ–Ω—Ç–∏' : '–µ–ª–µ–º–µ–Ω—Ç—ñ–≤');
                            bracketText = `[ ${node.length} ${itemText} ]`;
                        } else {
                            const keyCount = Object.keys(node).length;
                            const keyText = keyCount === 1 ? '–∫–ª—é—á' : (keyCount < 5 ? '–∫–ª—é—á—ñ' : '–∫–ª—é—á—ñ–≤');
                            bracketText = `{ ${keyCount} ${keyText} }`;
                        }
                    } else {
                        bracketText = isArray ? '[ - ]' : '{ - }';
                    }
                    
                    toggleSpan.innerHTML += `<span class="json-bracket">${bracketText}</span>`;

                    toggleSpan.addEventListener('click', (e) => {
                        e.stopPropagation();
                        li.classList.toggle('collapsed');
                        const isCollapsed = li.classList.contains('collapsed');
                        
                        // Dynamically calculate bracket text with count info
                        let bracketText;
                        if (isCollapsed) {
                            if (isArray) {
                                const itemText = node.length === 1 ? '–µ–ª–µ–º–µ–Ω—Ç' : (node.length < 5 ? '–µ–ª–µ–º–µ–Ω—Ç–∏' : '–µ–ª–µ–º–µ–Ω—Ç—ñ–≤');
                                bracketText = `[ ${node.length} ${itemText} ]`;
                            } else {
                                const keyCount = Object.keys(node).length;
                                const keyText = keyCount === 1 ? '–∫–ª—é—á' : (keyCount < 5 ? '–∫–ª—é—á—ñ' : '–∫–ª—é—á—ñ–≤');
                                bracketText = `{ ${keyCount} ${keyText} }`;
                            }
                        } else {
                            bracketText = isArray ? '[ - ]' : '{ - }';
                        }
                        
                        let currentKeyHtml = '';
                        if (path !== '$' && path.includes('.')) {
                            const key = path.substring(path.lastIndexOf('.') + 1);
                            currentKeyHtml = `<span class="json-key">"${escapeHtml(key)}"</span><span class="json-colon">:</span> `;
                        } else if (path !== '$' && path.includes('[')) {
                            // Show array index or key for array items
                            const indexMatch = path.match(/\[([^\]]+)\]$/);
                            if (indexMatch) {
                                const indexOrKey = indexMatch[1];
                                if (indexOrKey.includes('=')) {
                                    // Key-based indexing like [id=123]
                                    const [keyName, keyValue] = indexOrKey.split('=');
                                    currentKeyHtml = `<span class="json-key array-index">[${keyName}: ${keyValue}]</span> `;
                                } else {
                                    // Numeric index like [0]
                                    currentKeyHtml = `<span class="json-key array-index">[${indexOrKey}]</span> `;
                                }
                            }
                        }
                        toggleSpan.innerHTML = `${currentKeyHtml}<span class="json-bracket">${bracketText}</span>`;
                        
                        // Toggle child ul visibility
                        const childUlElement = li.querySelector('ul.nested');
                        if (childUlElement) {
                            childUlElement.style.display = isCollapsed ? 'none' : 'block';
                        }
                        
                        // Debounce height synchronization for better performance
                        clearTimeout(window.heightSyncTimeout);
                        window.heightSyncTimeout = setTimeout(synchronizeJsonViewHeights, 150);
                    });
                    li.appendChild(toggleSpan);

                    if (isArray) {
                        li.classList.add('array-node');
                        // Collapse nested nodes but keep root expanded
                        if (path !== '$') {
                            li.classList.add('collapsed');
                        }
                    } else {
                        li.classList.add('object-node');
                        // Collapse nested nodes but keep root expanded
                        if (path !== '$') {
                            li.classList.add('collapsed');
                        }
                    }

                    const childUl = document.createElement('ul');
                    childUl.classList.add('nested');
                    
                    // Set initial visibility based on collapsed state
                    if (path !== '$') {
                        childUl.style.display = 'none'; // Initially hidden for non-root nodes
                    } else {
                        childUl.style.display = 'block'; // Root node is always expanded initially
                    }

                    if (isArray) {
                        const innerPotentialKeys = ['id', 'productId', 'variantId', 'reviewId', 'key', 'name'];
                        const innerBestKey = innerPotentialKeys.find(key => node.every(item => item && typeof item === 'object' && item[key] !== undefined));

                        node.forEach((item, index) => {
                            let itemPath = `${path}[${index}]`;
                            if (innerBestKey && typeof item === 'object' && item !== null && item[innerBestKey] !== undefined) {
                                itemPath = `${path}[${innerBestKey}=${JSON.stringify(item[innerBestKey])}]`;
                            }
                            buildTree(item, itemPath, childUl);
                        });
                    } else { // Object
                        Object.keys(node).forEach(key => {
                            const propPath = `${path}.${key}`;
                            const value = node[key];
                            const childLi = document.createElement('li');
                            childLi.dataset.path = propPath;
                            const lineClass = getLineClass(propPath, true, diffMap, side);
                            if (lineClass && lineClass.trim()) {
                                childLi.classList.add(lineClass);
                            }
                            
                            if (typeof value !== 'object' || value === null) {
                                // Primitive value: display key-value directly in this <li>
                                try {
                                    childLi.innerHTML = `<span class="json-key">"${escapeHtml(key)}"</span><span class="json-colon">:</span> ${applySyntaxHighlighting(value)}`;
                                } catch (e) {
                                    console.error('Error rendering primitive value:', e);
                                    childLi.textContent = `"${key}": ${String(value)}`;
                                }
                            } else {
                                // Nested object/array: this <li> will have a toggle and a nested <ul>
                                const nestedToggleSpan = document.createElement('span');
                                nestedToggleSpan.classList.add('tree-toggle');
                                // Show count info for nested objects/arrays
                                let nestedBracketText;
                                if (Array.isArray(value)) {
                                    const itemText = value.length === 1 ? '–µ–ª–µ–º–µ–Ω—Ç' : (value.length < 5 ? '–µ–ª–µ–º–µ–Ω—Ç–∏' : '–µ–ª–µ–º–µ–Ω—Ç—ñ–≤');
                                    nestedBracketText = `[ ${value.length} ${itemText} ]`;
                                } else {
                                    const keyCount = Object.keys(value).length;
                                    const keyText = keyCount === 1 ? '–∫–ª—é—á' : (keyCount < 5 ? '–∫–ª—é—á—ñ' : '–∫–ª—é—á—ñ–≤');
                                    nestedBracketText = `{ ${keyCount} ${keyText} }`;
                                }
                                nestedToggleSpan.innerHTML = `<span class="json-key">"${escapeHtml(key)}"</span><span class="json-colon">:</span> <span class="json-bracket">${nestedBracketText}</span>`;
                                
                                nestedToggleSpan.addEventListener('click', (e) => {
                                    e.stopPropagation();
                                    childLi.classList.toggle('collapsed');
                                    const isCollapsed = childLi.classList.contains('collapsed');
                                    
                                    // Show count info when collapsed, simple brackets when expanded
                                    let bracketText;
                                    if (isCollapsed) {
                                        if (Array.isArray(value)) {
                                            const itemText = value.length === 1 ? '–µ–ª–µ–º–µ–Ω—Ç' : (value.length < 5 ? '–µ–ª–µ–º–µ–Ω—Ç–∏' : '–µ–ª–µ–º–µ–Ω—Ç—ñ–≤');
                                            bracketText = `[ ${value.length} ${itemText} ]`;
                                        } else {
                                            const keyCount = Object.keys(value).length;
                                            const keyText = keyCount === 1 ? '–∫–ª—é—á' : (keyCount < 5 ? '–∫–ª—é—á—ñ' : '–∫–ª—é—á—ñ–≤');
                                            bracketText = `{ ${keyCount} ${keyText} }`;
                                        }
                                    } else {
                                        bracketText = Array.isArray(value) ? '[ - ]' : '{ - }';
                                    }
                                    nestedToggleSpan.innerHTML = `<span class="json-key">"${escapeHtml(key)}"</span><span class="json-colon">:</span> <span class="json-bracket">${bracketText}</span>`;
                                    
                                    // Toggle child ul visibility
                                    const childUlElement = childLi.querySelector('ul.nested');
                                    if (childUlElement) {
                                        childUlElement.style.display = isCollapsed ? 'none' : 'block';
                                    }
                                    
                                    // Debounce height synchronization for better performance
                                    clearTimeout(window.heightSyncTimeout);
                                    window.heightSyncTimeout = setTimeout(synchronizeJsonViewHeights, 150);
                                });
                                childLi.appendChild(nestedToggleSpan);

                                const innerUl = document.createElement('ul');
                                innerUl.classList.add('nested');
                                if (Array.isArray(value)) innerUl.classList.add('array-node'); else innerUl.classList.add('object-node');
                                // Initial nested elements are collapsed
                                childLi.classList.add('collapsed');
                                innerUl.style.display = 'none'; // Initially hidden

                                buildTree(value, propPath, innerUl); // Recurse for the nested object/array
                                childLi.appendChild(innerUl);
                            }
                            childUl.appendChild(childLi);
                        });
                    }
                    li.appendChild(childUl); // Append the child list to the current li
                } else {
                    // Primitive value node
                    try {
                        li.innerHTML = applySyntaxHighlighting(node);
                    } catch (e) {
                        console.error('Error rendering primitive node:', e);
                        li.textContent = String(node);
                    }
                }
                parentUl.appendChild(li);
            }

            // Initial build for the root node
            buildTree(data, '$', ul);
            containerElement.appendChild(ul);
            
            // Ensure root level items are visible
            const rootItems = ul.querySelectorAll('ul.nested');
            rootItems.forEach(item => {
                if (item.parentElement.dataset.path === '$') {
                    item.style.display = 'block';
                }
            });
            
            console.log('JSON tree created successfully for', side, 'with', diffs.length, 'differences');
            synchronizeJsonViewHeights(); // Adjust heights after tree is built
        }

        // --- JSON View Toggle Logic ---
        function setupJsonViewToggle(sourceJson, targetJson, differences) {
            const radioButtons = document.querySelectorAll('input[name="jsonViewMode"]');
            const sourceCodeView = document.getElementById('sourceJsonViewCode');
            const targetCodeView = document.getElementById('targetJsonViewCode');
            const sourceTreeView = document.getElementById('sourceJsonViewTree');
            const targetTreeView = document.getElementById('targetJsonViewTree');
            
            // Re-create tree views every time to ensure they reflect current diffs/settings
            if (sourceJson) {
                createJsonTree(sourceJson, sourceTreeView, differences, 'source');
            } else {
                sourceTreeView.innerHTML = ''; // Clear if no source JSON
            }
            if (targetJson) {
                createJsonTree(targetJson, targetTreeView, differences, 'target');
            } else {
                targetTreeView.innerHTML = ''; // Clear if no target JSON
            }

            // Add event listeners to existing radio buttons
            radioButtons.forEach(radio => {
                radio.addEventListener('change', handleJsonViewChange);
            });

            function handleJsonViewChange(event) {
                if (event.target.value === 'code') {
                    if (sourceCodeView) sourceCodeView.style.display = 'block';
                    if (sourceTreeView) sourceTreeView.style.display = 'none';
                    if (targetCodeView) targetCodeView.style.display = 'block';
                    if (targetTreeView) targetTreeView.style.display = 'none';
                } else { // tree mode
                    if (sourceCodeView) sourceCodeView.style.display = 'none';
                    if (sourceTreeView) sourceTreeView.style.display = 'block';
                    if (targetCodeView) targetCodeView.style.display = 'none';
                    if (targetTreeView) targetTreeView.style.display = 'block';
                }
                synchronizeJsonViewHeights(); // Re-adjust heights after mode change
            }

            // Ensure initial state is "code" and heights are synced
            if (document.querySelector('input[name="jsonViewMode"][value="code"]').checked) {
                 synchronizeJsonViewHeights();
            } else {
                 // If tree mode was checked, ensure tree views are displayed
                if (sourceCodeView) sourceCodeView.style.display = 'none';
                if (sourceTreeView) sourceTreeView.style.display = 'block';
                if (targetCodeView) targetCodeView.style.display = 'none';
                if (targetTreeView) targetTreeView.style.display = 'block';
                synchronizeJsonViewHeights();
            }
        }


        // --- Global utility functions (moved to global scope to avoid duplication) ---
        function synchronizeJsonViewHeights() {
            const sourceViewCode = document.getElementById('sourceJsonViewCode'); 
            const targetViewCode = document.getElementById('targetJsonViewCode');
            const sourceViewTree = document.getElementById('sourceJsonViewTree');
            const targetViewTree = document.getElementById('targetJsonViewTree');

            const isCodeMode = document.querySelector('input[name="jsonViewMode"][value="code"]')?.checked || true;

            let currentSourceView = isCodeMode ? sourceViewCode : sourceViewTree;
            let currentTargetView = isCodeMode ? targetViewCode : targetViewTree;

            // Reset heights
            if (sourceViewCode) sourceViewCode.style.height = 'auto';
            if (targetViewCode) targetViewCode.style.height = 'auto';
            if (sourceViewTree) sourceViewTree.style.height = 'auto';
            if (targetViewTree) targetViewTree.style.height = 'auto';

            // Set max height for visible views
            if (currentSourceView && currentTargetView) {
                const maxHeight = Math.max(currentSourceView.scrollHeight, currentTargetView.scrollHeight);
                currentSourceView.style.height = `${maxHeight}px`;
                currentTargetView.style.height = `${maxHeight}px`;
            } else if (currentSourceView) { 
                currentSourceView.style.height = `${currentSourceView.scrollHeight}px`;
            } else if (currentTargetView) { 
                currentTargetView.style.height = `${currentTargetView.scrollHeight}px`;
            }
        }
        
        function setupCollapsibleSections() {
            document.querySelectorAll('.collapsible-header').forEach(header => {
                // Remove existing listeners to prevent duplicates
                const newHeader = header.cloneNode(true);
                header.parentNode.replaceChild(newHeader, header);
                newHeader.addEventListener('click', toggleCollapsible);
            });
        }

        function toggleCollapsible() {
            this.closest('.collapsible-section').classList.toggle('collapsed');
            setTimeout(synchronizeJsonViewHeights, 450); 
        }

        // --- Memory Management ---
        let globalEventCleanup = [];

        function addGlobalEventListener(element, event, handler, options = {}) {
            element.addEventListener(event, handler, options);
            globalEventCleanup.push(() => element.removeEventListener(event, handler, options));
        }

        function cleanupGlobalEvents() {
            globalEventCleanup.forEach(cleanup => {
                try {
                    cleanup();
                } catch (e) {
                    console.warn('Error during cleanup:', e);
                }
            });
            globalEventCleanup = [];
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', cleanupGlobalEvents);

        // --- Loading Management ---
        function showLoader() {
            const loader = document.getElementById('loader');
            if (loader) {
                loader.style.display = 'flex';
            }
        }

        function hideLoader() {
            const loader = document.getElementById('loader');
            if (loader) {
                loader.style.display = 'none';
            }
        }

        // --- Performance Optimization ---
        
        // Chunk processing for large operations to prevent UI blocking
        function processInChunks(items, processor, chunkSize = 100, delay = 10) {
            return new Promise((resolve, reject) => {
                let index = 0;
                const results = [];

                function processChunk() {
                    const chunk = items.slice(index, index + chunkSize);
                    
                    try {
                        for (const item of chunk) {
                            results.push(processor(item));
                        }
                    } catch (error) {
                        reject(error);
                        return;
                    }

                    index += chunkSize;

                    if (index < items.length) {
                        setTimeout(processChunk, delay);
                    } else {
                        resolve(results);
                    }
                }

                processChunk();
            });
        }

        // Debounce function to limit frequent operations
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Throttle function for scroll events
        function throttle(func, limit) {
            let inThrottle;
            return function() {
                const args = arguments;
                const context = this;
                if (!inThrottle) {
                    func.apply(context, args);
                    inThrottle = true;
                    setTimeout(() => inThrottle = false, limit);
                }
            }
        }

        // Virtual scrolling for large tables (basic implementation)
        function setupVirtualScrolling(container, items, renderItem, itemHeight = 40) {
            const totalHeight = items.length * itemHeight;
            const visibleCount = Math.ceil(container.clientHeight / itemHeight);
            let scrollTop = 0;

            const viewport = document.createElement('div');
            viewport.style.height = totalHeight + 'px';
            viewport.style.position = 'relative';

            const content = document.createElement('div');
            content.style.position = 'absolute';
            content.style.top = '0';
            content.style.width = '100%';

            viewport.appendChild(content);
            container.appendChild(viewport);

            function updateView() {
                const startIndex = Math.floor(scrollTop / itemHeight);
                const endIndex = Math.min(startIndex + visibleCount + 5, items.length);
                
                content.style.transform = `translateY(${startIndex * itemHeight}px)`;
                content.innerHTML = '';

                for (let i = startIndex; i < endIndex; i++) {
                    const item = renderItem(items[i], i);
                    item.style.height = itemHeight + 'px';
                    content.appendChild(item);
                }
            }

            container.addEventListener('scroll', throttle(() => {
                scrollTop = container.scrollTop;
                updateView();
            }, 16)); // ~60fps

            updateView();
        }

        // --- Scroll to Top Functionality ---
        function setupScrollToTop() {
            const scrollToTopBtn = document.getElementById('scrollToTopBtn');
            if (!scrollToTopBtn) return;

            // Show/hide button based on scroll position
            function toggleScrollButton() {
                if (window.pageYOffset > 300) {
                    scrollToTopBtn.classList.add('show');
                } else {
                    scrollToTopBtn.classList.remove('show');
                }
            }

            // Smooth scroll to top
            function scrollToTop() {
                window.scrollTo({
                    top: 0,
                    behavior: 'smooth'
                });
            }

            // Add event listeners
            window.addEventListener('scroll', throttle(toggleScrollButton, 100));
            scrollToTopBtn.addEventListener('click', scrollToTop);

            // Initial check
            toggleScrollButton();
        }

        // --- Accessibility Functions ---
        function announceToScreenReader(message, priority = 'polite') {
            const liveRegion = document.getElementById('live-region');
            if (liveRegion) {
                liveRegion.setAttribute('aria-live', priority);
                liveRegion.textContent = message;
                
                // Clear after a delay to prevent repetition
                setTimeout(() => {
                    liveRegion.textContent = '';
                }, 1000);
            }
        }

        function updateAriaInvalid(element, isInvalid) {
            if (element) {
                element.setAttribute('aria-invalid', isInvalid ? 'true' : 'false');
            }
        }

        // Add keyboard navigation support
        function addKeyboardSupport() {
            document.addEventListener('keydown', (e) => {
                // Allow Escape to close modals
                if (e.key === 'Escape') {
                    const openModal = document.querySelector('.modal-overlay[style*="flex"]');
                    if (openModal) {
                        openModal.style.display = 'none';
                        e.preventDefault();
                    }
                }
            });

            // Improve tab navigation for tooltips
            document.querySelectorAll('.tooltip-container').forEach(container => {
                if (!container.hasAttribute('tabindex')) {
                    container.setAttribute('tabindex', '0');
                }
                
                let focusTimeoutId;
                
                addGlobalEventListener(container, 'focus', () => {
                    const tooltip = container.querySelector('.tooltip');
                    if (tooltip) {
                        clearTimeout(focusTimeoutId);
                        // –ó–∞—Ç—Ä–∏–º–∫–∞ 2 —Å–µ–∫—É–Ω–¥–∏ –¥–ª—è focus —Ç–∞–∫–æ–∂
                        focusTimeoutId = setTimeout(() => {
                            // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —á–∏ –µ–ª–µ–º–µ–Ω—Ç –≤—Å–µ —â–µ –º–∞—î —Ñ–æ–∫—É—Å
                            if (document.activeElement === container || container.contains(document.activeElement)) {
                                positionTooltip(container, tooltip);
                                tooltip.style.visibility = 'visible';
                                tooltip.style.opacity = '1';
                                tooltip.style.transform = 'translateY(0)';
                            }
                        }, 2000);
                    }
                });

                addGlobalEventListener(container, 'blur', () => {
                    const tooltip = container.querySelector('.tooltip');
                    if (tooltip) {
                        clearTimeout(focusTimeoutId); // –°–∫–∞—Å–æ–≤—É—î–º–æ –ø–æ–∫–∞–∑ tooltip'–∞ –ø—Ä–∏ –≤—Ç—Ä–∞—Ç—ñ —Ñ–æ–∫—É—Å–∞
                        tooltip.style.visibility = 'hidden';
                        tooltip.style.opacity = '0';
                        tooltip.style.transform = 'translateY(10px)';
                    }
                });
            });
        }

        // --- Missing utility functions ---
        function updateUiForMode() {
            const currentMode = document.querySelector('input[name="compareMode"]:checked')?.value || 'direct';
            const dropZoneSchema = document.getElementById('dropZoneSchema');
            
            if (currentMode === 'schema') {
                dropZoneSchema.classList.remove('hidden');
                dropZoneSchema.style.display = 'block';
                
                // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—ñ AJV –ø—Ä–∏ –≤–∏–±–æ—Ä—ñ —Ä–µ–∂–∏–º—É —Å—Ö–µ–º–∏
                if (!isAjvAvailable()) {
                    showToast('‚ö†Ô∏è AJV –±—ñ–±–ª—ñ–æ—Ç–µ–∫–∞ –Ω–µ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–∞. –í–∞–ª—ñ–¥–∞—Ü—ñ—è —Å—Ö–µ–º–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞. –ü–µ—Ä–µ–∑–∞–≤–∞–Ω—Ç–∞–∂—Ç–µ —Å—Ç–æ—Ä—ñ–Ω–∫—É.', 'error', 5000);
                }
            } else {
                dropZoneSchema.classList.add('hidden'); 
                dropZoneSchema.style.display = 'none';
            }
        }

        function loadSettings() {
            try {
                const savedSettings = localStorage.getItem('jsonComparatorSettings');
                if (savedSettings) {
                    const settings = JSON.parse(savedSettings);
                    
                    // Load ignore paths
                    const ignorePathsField = document.getElementById('ignorePaths');
                    if (ignorePathsField && settings.ignorePaths) {
                        ignorePathsField.value = settings.ignorePaths.join('\n');
                    }
                    
                    // Load array compare mode
                    const arrayModeRadio = document.querySelector(`input[name="arrayCompareMode"][value="${settings.arrayCompareMode || 'key'}"]`);
                    if (arrayModeRadio) {
                        arrayModeRadio.checked = true;
                    }
                    
                    // Load case sensitivity
                    const caseSensitiveCheck = document.getElementById('caseSensitive');
                    if (caseSensitiveCheck) {
                        caseSensitiveCheck.checked = settings.caseSensitive !== false;
                    }
                }
            } catch (error) {
                console.warn('Failed to load settings:', error);
            }
        }

        function saveSettings() {
            try {
                const ignorePathsField = document.getElementById('ignorePaths');
                const arrayCompareMode = document.querySelector('input[name="arrayCompareMode"]:checked')?.value || 'key';
                const caseSensitive = document.getElementById('caseSensitive')?.checked || true;
                
                const settings = {
                    ignorePaths: ignorePathsField ? ignorePathsField.value.split('\n').filter(path => path.trim()) : [],
                    arrayCompareMode: arrayCompareMode,
                    caseSensitive: caseSensitive
                };
                
                localStorage.setItem('jsonComparatorSettings', JSON.stringify(settings));
                
                // Update global settings variable if it exists
                if (typeof window.settings !== 'undefined') {
                    window.settings = settings;
                }
                
                // Close modal
                const settingsModal = document.getElementById('settingsModal');
                if (settingsModal) {
                    settingsModal.style.display = 'none';
                }
                
                showToast('–ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –∑–±–µ—Ä–µ–∂–µ–Ω–æ!', 'success');
            } catch (error) {
                console.error('Failed to save settings:', error);
                showToast('–ü–æ–º–∏–ª–∫–∞ –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω—å!', 'error');
            }
        }

        function initializeTooltips() {
            // Add tooltip listeners to existing containers without cloning
            const containers = document.querySelectorAll('.tooltip-container');
            console.log(`Initializing ${containers.length} tooltip containers`);
            containers.forEach(container => {
                addTooltipListeners(container);
            });
        }

        function addTooltipListeners(container) {
            const tooltip = container.querySelector('.tooltip');
            if (!tooltip) return;

            let showTimeoutId;
            let hideTimeoutId;
            let mousePosition = { x: 0, y: 0 };
            let isMouseOver = false; // –§–ª–∞–≥ –≤—ñ–¥—Å—Ç–µ–∂–µ–Ω–Ω—è –ø–æ–∑–∏—Ü—ñ—ó –∫—É—Ä—Å–æ—Ä–∞
            
            // –û—á–∏—â–∞—î–º–æ –≤—Å—ñ —ñ—Å–Ω—É—é—á—ñ timeout'–∏ –ø—Ä–∏ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—ó
            clearTimeout(showTimeoutId);
            clearTimeout(hideTimeoutId);
            
            // –ü—Ä–∏—Ö–æ–≤—É—î–º–æ tooltip –ø—Ä–∏ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—ó
            tooltip.style.visibility = 'hidden';
            tooltip.style.opacity = '0';
            
            /* 
             * –õ–æ–≥—ñ–∫–∞ —Ä–æ–±–æ—Ç–∏ tooltip'—ñ–≤:
             * 1. –ü—Ä–∏ mouseenter - –∑–∞–ø—É—Å–∫–∞—î—Ç—å—Å—è —Ç–∞–π–º–µ—Ä –Ω–∞ 2 —Å–µ–∫—É–Ω–¥–∏
             * 2. –ü—Ä–∏ mouseleave - —Ç–∞–π–º–µ—Ä —Å–∫–∞—Å–æ–≤—É—î—Ç—å—Å—è + tooltip —Ö–æ–≤–∞—î—Ç—å—Å—è —è–∫—â–æ –±—É–≤ –≤–∏–¥–∏–º–∏–π
             * 3. –ß–µ—Ä–µ–∑ 2 —Å–µ–∫—É–Ω–¥–∏ –ø–µ—Ä–µ–≤—ñ—Ä—è—î—Ç—å—Å—è —á–∏ –∫—É—Ä—Å–æ—Ä –≤—Å–µ —â–µ –Ω–∞ –µ–ª–µ–º–µ–Ω—Ç—ñ (–ø–æ–¥–≤—ñ–π–Ω–∞ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞)
             * 4. –¢—ñ–ª—å–∫–∏ —è–∫—â–æ –∫—É—Ä—Å–æ—Ä –∑–∞–ª–∏—à–∞–≤—Å—è –Ω–∞ –µ–ª–µ–º–µ–Ω—Ç—ñ - –ø–æ–∫–∞–∑—É—î—Ç—å—Å—è tooltip
             */

            // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –ø—Ä–∏—Ö–æ–≤—É–≤–∞–Ω–Ω—è tooltip'–∞
            const hideTooltip = (delay = 100) => {
                clearTimeout(hideTimeoutId);
                hideTimeoutId = setTimeout(() => {
                    tooltip.style.visibility = 'hidden';
                    tooltip.style.opacity = '0';
                    tooltip.style.transform = 'translateY(10px)';
                }, delay);
            };

            // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –ø–æ–∫–∞–∑—É tooltip'–∞
            const showTooltip = () => {
                clearTimeout(hideTimeoutId);
                positionTooltipNearCursor(tooltip, mousePosition);
                tooltip.style.visibility = 'visible';
                tooltip.style.opacity = '1';
                tooltip.style.transform = 'translateY(0)';
            };

            const mouseMoveHandler = (e) => {
                // –û–Ω–æ–≤–ª—é—î–º–æ –ø–æ–∑–∏—Ü—ñ—é –∫—É—Ä—Å–æ—Ä–∞ –¥–ª—è —Ç–æ—á–Ω–æ–≥–æ –ø–æ–∑–∏—Ü—ñ–æ–Ω—É–≤–∞–Ω–Ω—è tooltip'–∞
                mousePosition.x = e.clientX;
                mousePosition.y = e.clientY;
            };

            const mouseEnterHandler = (e) => {
                isMouseOver = true; // –ö—É—Ä—Å–æ—Ä –Ω–∞ –µ–ª–µ–º–µ–Ω—Ç—ñ
                clearTimeout(showTimeoutId);
                clearTimeout(hideTimeoutId);
                
                mousePosition.x = e.clientX;
                mousePosition.y = e.clientY;
                
                // –ó–∞—Ç—Ä–∏–º–∫–∞ 2 —Å–µ–∫—É–Ω–¥–∏ –ø–µ—Ä–µ–¥ –ø–æ–∫–∞–∑–æ–º tooltip
                showTimeoutId = setTimeout(() => {
                    // –ü–æ–¥–≤—ñ–π–Ω–∞ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞: —Ñ–ª–∞–≥ + —Ä–µ–∞–ª—å–Ω–∞ –ø–æ–∑–∏—Ü—ñ—è –∫—É—Ä—Å–æ—Ä–∞
                    const elementUnderCursor = document.elementFromPoint(mousePosition.x, mousePosition.y);
                    const isStillOverElement = isMouseOver && (
                        elementUnderCursor === container || 
                        container.contains(elementUnderCursor)
                    );
                    
                    if (isStillOverElement) {
                        showTooltip();
                    }
                }, 2000);
            };

            const mouseLeaveHandler = () => {
                isMouseOver = false; // –ö—É—Ä—Å–æ—Ä –ø–æ–∫–∏–Ω—É–≤ –µ–ª–µ–º–µ–Ω—Ç
                clearTimeout(showTimeoutId); // –°–∫–∞—Å–æ–≤—É—î–º–æ –ø–æ–∫–∞–∑ tooltip'–∞
                
                // –•–æ–≤–∞—î–º–æ tooltip —è–∫—â–æ –≤—ñ–Ω –≤–∏–¥–∏–º–∏–π
                if (tooltip.style.visibility === 'visible') {
                    hideTooltip();
                }
            };

            // –î–æ–¥–∞—î–º–æ –æ–±—Ä–æ–±–Ω–∏–∫–∏ –¥–ª—è mouse events
            addGlobalEventListener(container, 'mousemove', mouseMoveHandler);
            addGlobalEventListener(container, 'mouseenter', mouseEnterHandler);
            addGlobalEventListener(container, 'mouseleave', mouseLeaveHandler);
            
            // –î–æ–¥–∞—î–º–æ –æ–±—Ä–æ–±–Ω–∏–∫–∏ –¥–ª—è touch events (–º–æ–±—ñ–ª—å–Ω—ñ –ø—Ä–∏—Å—Ç—Ä–æ—ó)
            let touchTimeoutId;
            
            addGlobalEventListener(container, 'touchstart', (e) => {
                clearTimeout(touchTimeoutId);
                const touch = e.touches[0];
                mousePosition.x = touch.clientX;
                mousePosition.y = touch.clientY;
                
                touchTimeoutId = setTimeout(() => {
                    // –î–ª—è touch events –ø–æ–∫–∞–∑—É—î–º–æ tooltip –æ–¥—Ä–∞–∑—É –ø—ñ—Å–ª—è —Ç–∞–π–º–∞—É—Ç—É
                    showTooltip();
                }, 2000);
            });
            
            addGlobalEventListener(container, 'touchend', () => {
                clearTimeout(touchTimeoutId);
                if (tooltip.style.visibility === 'visible') {
                    hideTooltip();
                }
            });
        }

        function positionTooltipNearCursor(tooltip, mousePos) {
            const windowHeight = window.innerHeight;
            const windowWidth = window.innerWidth;
            const offset = 15; // Distance from cursor



            // Reset positioning styles
            tooltip.style.position = 'fixed';
            tooltip.style.left = 'auto';
            tooltip.style.right = 'auto';
            tooltip.style.top = 'auto';
            tooltip.style.bottom = 'auto';
            tooltip.style.transform = 'none';
            tooltip.style.margin = '0';

            // Get tooltip dimensions (make it temporarily visible for measurement)
            const wasVisible = tooltip.style.visibility === 'visible';
            if (!wasVisible) {
                tooltip.style.visibility = 'hidden';
                tooltip.style.opacity = '1';
            }
            
            const tooltipRect = tooltip.getBoundingClientRect();
            const tooltipWidth = tooltipRect.width || 200; // fallback width
            const tooltipHeight = tooltipRect.height || 50; // fallback height

            // Calculate preferred position (right of cursor)
            let left = mousePos.x + offset;
            let top = mousePos.y - tooltipHeight / 2;

            // Check boundaries and adjust
            if (left + tooltipWidth > windowWidth - 10) {
                // If doesn't fit on right, place on left
                left = mousePos.x - tooltipWidth - offset;
            }

            if (left < 10) {
                // If still doesn't fit, position at edge
                left = 10;
            }

            if (top < 10) {
                top = 10;
            } else if (top + tooltipHeight > windowHeight - 10) {
                top = windowHeight - tooltipHeight - 10;
            }

            // Apply final position
            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';

            // Restore visibility state
            if (!wasVisible) {
                tooltip.style.visibility = 'hidden';
                tooltip.style.opacity = '0';
            }
        }

        // Legacy function for focus-based positioning
        function positionTooltip(container, tooltip) {
            const containerRect = container.getBoundingClientRect();
            const mousePos = {
                x: containerRect.left + containerRect.width / 2,
                y: containerRect.top + containerRect.height / 2
            };
            positionTooltipNearCursor(tooltip, mousePos);
        }

        // --- Global utility functions for file handling ---
        
        // Global state variables
        let sourceFileContent = null;
        let targetFileContent = null;
        let schemaFileContent = null;
        let globalDifferences = [];
        let currentMode = 'direct';
        let settings = {
            ignorePaths: [],
            arrayCompareMode: 'key',
            caseSensitive: true,
        };

        // Analytics and visualization state
        let analyticsCharts = {};
        let currentViewMode = 'table'; // 'table', 'grouped', 'tree'

        // === VISUAL ENHANCEMENTS & ANALYTICS FUNCTIONS ===

        // Minimap Navigation
        function createMinimap(differences) {
            const minimapContainer = document.createElement('div');
            minimapContainer.className = 'minimap-container';
            
            const header = document.createElement('div');
            header.className = 'minimap-header';
            header.textContent = 'üó∫Ô∏è –ù–∞–≤—ñ–≥–∞—Ü—ñ—è';
            minimapContainer.appendChild(header);

            // Group differences by path hierarchy for better navigation
            const pathGroups = {};
            differences.forEach((diff, index) => {
                const pathParts = diff.path.split('.');
                const topLevel = pathParts.length > 1 ? pathParts[1] : pathParts[0];
                if (!pathGroups[topLevel]) {
                    pathGroups[topLevel] = [];
                }
                pathGroups[topLevel].push({ ...diff, originalIndex: index });
            });

            Object.keys(pathGroups).forEach(groupName => {
                const groupItems = pathGroups[groupName];
                const firstItem = groupItems[0];
                
                const minimapItem = document.createElement('div');
                minimapItem.className = `minimap-item ${getMinimapClass(firstItem.type)}`;
                
                const pathSpan = document.createElement('span');
                pathSpan.className = 'minimap-path';
                pathSpan.textContent = `${groupName} (${groupItems.length})`;
                minimapItem.appendChild(pathSpan);

                minimapItem.addEventListener('click', () => {
                    scrollToTableRow(firstItem.originalIndex);
                    highlightTableRow(firstItem.originalIndex);
                });

                minimapContainer.appendChild(minimapItem);
            });

            return minimapContainer;
        }

        function getMinimapClass(diffType) {
            if (diffType.toLowerCase().includes('add')) return 'added';
            if (diffType.toLowerCase().includes('remov')) return 'removed';
            if (diffType.toLowerCase().includes('schema')) return 'schema-error';
            return 'changed';
        }

        function scrollToTableRow(index) {
            const table = document.querySelector('#results table');
            if (table) {
                const rows = table.querySelectorAll('tbody tr');
                if (rows[index]) {
                    rows[index].scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }
        }

        function highlightTableRow(index) {
            // Remove previous highlights
            document.querySelectorAll('.highlighted-row').forEach(row => {
                row.classList.remove('highlighted-row');
            });

            const table = document.querySelector('#results table');
            if (table) {
                const rows = table.querySelectorAll('tbody tr');
                if (rows[index]) {
                    rows[index].classList.add('highlighted-row');
                    setTimeout(() => {
                        rows[index].classList.remove('highlighted-row');
                    }, 3000);
                }
            }
        }

        // Character-level inline diff
        function createInlineDiff(oldText, newText) {
            if (!oldText && !newText) return '';
            if (!oldText) return `<span class="char-added">${escapeHtml(newText)}</span>`;
            if (!newText) return `<span class="char-removed">${escapeHtml(oldText)}</span>`;

            // Simple character-level diff algorithm
            const oldStr = String(oldText);
            const newStr = String(newText);
            
            if (oldStr === newStr) {
                return `<span class="char-unchanged">${escapeHtml(oldStr)}</span>`;
            }

            // Use LCS (Longest Common Subsequence) for better diff
            const diff = computeCharDiff(oldStr, newStr);
            return diff.map(part => {
                if (part.type === 'equal') {
                    return `<span class="char-unchanged">${escapeHtml(part.value)}</span>`;
                } else if (part.type === 'delete') {
                    return `<span class="char-removed">${escapeHtml(part.value)}</span>`;
                } else {
                    return `<span class="char-added">${escapeHtml(part.value)}</span>`;
                }
            }).join('');
        }

        function computeCharDiff(oldStr, newStr) {
            // Simplified diff algorithm
            const result = [];
            let i = 0, j = 0;
            
            while (i < oldStr.length || j < newStr.length) {
                if (i < oldStr.length && j < newStr.length && oldStr[i] === newStr[j]) {
                    // Characters match
                    let start = i;
                    while (i < oldStr.length && j < newStr.length && oldStr[i] === newStr[j]) {
                        i++; j++;
                    }
                    result.push({ type: 'equal', value: oldStr.substring(start, i) });
                } else {
                    // Characters don't match
                    let deletedPart = '';
                    let addedPart = '';
                    
                    // Collect deleted characters
                    while (i < oldStr.length && (j >= newStr.length || oldStr[i] !== newStr[j])) {
                        deletedPart += oldStr[i];
                        i++;
                    }
                    
                    // Collect added characters
                    while (j < newStr.length && (i >= oldStr.length || oldStr[i] !== newStr[j])) {
                        addedPart += newStr[j];
                        j++;
                    }
                    
                    if (deletedPart) result.push({ type: 'delete', value: deletedPart });
                    if (addedPart) result.push({ type: 'insert', value: addedPart });
                }
            }
            
            return result;
        }

        // Determine importance level for color coding
        function getImportanceLevel(diff) {
            const path = diff.path.toLowerCase();
            const type = diff.type.toLowerCase();
            
            // Critical importance
            if (type.includes('schema') || path.includes('id') || path.includes('key')) {
                return 'critical';
            }
            
            // High importance
            if (type.includes('type') || path.includes('status') || path.includes('state')) {
                return 'high';
            }
            
            // Medium importance
            if (type.includes('value') || path.includes('name') || path.includes('title')) {
                return 'medium';
            }
            
            // Low importance (default)
            return 'low';
        }

        // Grouped diff view
        function createGroupedDiffView(differences) {
            const grouped = {};
            
            differences.forEach(diff => {
                const groupKey = diff.type;
                if (!grouped[groupKey]) {
                    grouped[groupKey] = [];
                }
                grouped[groupKey].push(diff);
            });

            const container = document.createElement('div');
            container.className = 'grouped-diff';

            Object.keys(grouped).forEach(groupType => {
                const group = grouped[groupType];
                const groupDiv = document.createElement('div');
                groupDiv.className = 'diff-group';

                const header = document.createElement('div');
                header.className = 'group-header';
                header.innerHTML = `
                    <span>${groupType}</span>
                    <span class="group-count">${group.length}</span>
                `;

                const content = document.createElement('div');
                content.className = 'group-content';
                
                group.forEach(diff => {
                    const item = document.createElement('div');
                    item.className = `diff-item importance-${getImportanceLevel(diff)}`;
                    item.innerHTML = `
                        <div class="diff-path"><code>${escapeHtml(diff.path)}</code></div>
                        <div class="diff-reason">${escapeHtml(diff.reason)}</div>
                        <div class="diff-values">
                            <div class="old-value"><strong>–ë—É–ª–æ:</strong> <code>${escapeHtml(diff.oldValue || '–Ω/–¥')}</code></div>
                            <div class="new-value"><strong>–°—Ç–∞–ª–æ:</strong> <code>${escapeHtml(diff.newValue || '–Ω/–¥')}</code></div>
                        </div>
                    `;
                    content.appendChild(item);
                });

                header.addEventListener('click', () => {
                    content.classList.toggle('collapsed');
                });

                groupDiv.appendChild(header);
                groupDiv.appendChild(content);
                container.appendChild(groupDiv);
            });

            return container;
        }

        // Analytics Dashboard Creation
        function createAnalyticsDashboard(differences, sourceJson, targetJson) {
            const dashboard = document.createElement('div');
            dashboard.className = 'analytics-dashboard';

            const header = document.createElement('div');
            header.className = 'analytics-header';
            header.innerHTML = `
                <h3 class="analytics-title">üìä –ê–Ω–∞–ª—ñ—Ç–∏–∫–∞ –∑–º—ñ–Ω</h3>
                <div class="analytics-export">
                    <button onclick="exportAnalytics('excel')">Excel –∑–≤—ñ—Ç</button>
                    <button onclick="exportAnalytics('detailed-csv')">–î–µ—Ç–∞–ª—å–Ω–∏–π CSV</button>
                    <button onclick="generateInsights()">üí° –Ü–Ω—Å–∞–π—Ç–∏</button>
                </div>
            `;

            const grid = document.createElement('div');
            grid.className = 'analytics-grid';

            // Create various analytics cards
            grid.appendChild(createChangeDistributionChart(differences));
            grid.appendChild(createComplexityMetrics(differences, sourceJson, targetJson));
            grid.appendChild(createPathAnalysisChart(differences));
            grid.appendChild(createTimelineAnalysis(differences));

            dashboard.appendChild(header);
            dashboard.appendChild(grid);

            // Add heatmap if enough data
            if (differences.length > 10) {
                dashboard.appendChild(createStructureHeatmap(differences, sourceJson, targetJson));
            }

            return dashboard;
        }

        // Individual analytics components
        function createChangeDistributionChart(differences) {
            const card = document.createElement('div');
            card.className = 'analytics-card';
            card.innerHTML = `
                <div class="card-title">–†–æ–∑–ø–æ–¥—ñ–ª —Ç–∏–ø—ñ–≤ –∑–º—ñ–Ω</div>
                <div class="chart-container">
                    <canvas id="changeDistributionChart"></canvas>
                </div>
            `;

            // Count change types
            const typeCounts = {};
            differences.forEach(diff => {
                const type = diff.type;
                typeCounts[type] = (typeCounts[type] || 0) + 1;
            });

            // Create chart after element is added to DOM
            setTimeout(() => {
                if (typeof Chart !== 'undefined') {
                    const ctx = document.getElementById('changeDistributionChart');
                    if (ctx) {
                        analyticsCharts.distribution = new Chart(ctx, {
                            type: 'doughnut',
                            data: {
                                labels: Object.keys(typeCounts),
                                datasets: [{
                                    data: Object.values(typeCounts),
                                    backgroundColor: [
                                        '#28a745', '#dc3545', '#ffc107', 
                                        '#17a2b8', '#6f42c1', '#fd7e14'
                                    ]
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                plugins: {
                                    legend: {
                                        position: 'bottom',
                                        labels: {
                                            font: { size: 10 }
                                        }
                                    }
                                }
                            }
                        });
                    }
                }
            }, 100);

            return card;
        }

        function createComplexityMetrics(differences, sourceJson, targetJson) {
            const card = document.createElement('div');
            card.className = 'analytics-card';

            const sourceDepth = getObjectDepth(sourceJson);
            const targetDepth = getObjectDepth(targetJson);
            const avgPathLength = differences.reduce((sum, diff) => sum + diff.path.split('.').length, 0) / differences.length;
            const changeIntensity = differences.length / Math.max(getObjectSize(sourceJson), getObjectSize(targetJson));

            card.innerHTML = `
                <div class="card-title">–ú–µ—Ç—Ä–∏–∫–∏ —Å–∫–ª–∞–¥–Ω–æ—Å—Ç—ñ</div>
                <div class="metrics-list">
                    <div class="metric-item">
                        <span class="metric-label">–ì–ª–∏–±–∏–Ω–∞ Source:</span>
                        <span class="metric-value">${sourceDepth} —Ä—ñ–≤–Ω—ñ–≤</span>
                    </div>
                    <div class="metric-item">
                        <span class="metric-label">–ì–ª–∏–±–∏–Ω–∞ Target:</span>
                        <span class="metric-value">${targetDepth} —Ä—ñ–≤–Ω—ñ–≤</span>
                    </div>
                    <div class="metric-item">
                        <span class="metric-label">–°–µ—Ä–µ–¥–Ω—è –≥–ª–∏–±–∏–Ω–∞ –∑–º—ñ–Ω:</span>
                        <span class="metric-value">${avgPathLength.toFixed(1)}</span>
                    </div>
                    <div class="metric-item">
                        <span class="metric-label">–Ü–Ω—Ç–µ–Ω—Å–∏–≤–Ω—ñ—Å—Ç—å –∑–º—ñ–Ω:</span>
                        <span class="metric-value">${(changeIntensity * 100).toFixed(1)}%</span>
                    </div>
                </div>
            `;

            return card;
        }

        function getObjectSize(obj) {
            if (obj === null || obj === undefined) return 0;
            if (typeof obj !== 'object') return 1;
            
            let size = 0;
            if (Array.isArray(obj)) {
                size = obj.length;
                obj.forEach(item => size += getObjectSize(item));
            } else {
                size = Object.keys(obj).length;
                Object.values(obj).forEach(value => size += getObjectSize(value));
            }
            return size;
        }

        function createPathAnalysisChart(differences) {
            const card = document.createElement('div');
            card.className = 'analytics-card';
            card.innerHTML = `
                <div class="card-title">–ê–Ω–∞–ª—ñ–∑ —à–ª—è—Ö—ñ–≤ –∑–º—ñ–Ω</div>
                <div class="chart-container">
                    <canvas id="pathAnalysisChart"></canvas>
                </div>
            `;

            // Analyze path depths
            const depthCounts = {};
            differences.forEach(diff => {
                const depth = diff.path.split('.').length;
                depthCounts[depth] = (depthCounts[depth] || 0) + 1;
            });

            setTimeout(() => {
                if (typeof Chart !== 'undefined') {
                    const ctx = document.getElementById('pathAnalysisChart');
                    if (ctx) {
                        analyticsCharts.pathAnalysis = new Chart(ctx, {
                            type: 'bar',
                            data: {
                                labels: Object.keys(depthCounts).map(d => `–†—ñ–≤–µ–Ω—å ${d}`),
                                datasets: [{
                                    label: '–ö—ñ–ª—å–∫—ñ—Å—Ç—å –∑–º—ñ–Ω',
                                    data: Object.values(depthCounts),
                                    backgroundColor: '#007bff',
                                    borderColor: '#0056b3',
                                    borderWidth: 1
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                scales: {
                                    y: {
                                        beginAtZero: true,
                                        ticks: {
                                            stepSize: 1
                                        }
                                    }
                                },
                                plugins: {
                                    legend: {
                                        display: false
                                    }
                                }
                            }
                        });
                    }
                }
            }, 100);

            return card;
        }

        function createTimelineAnalysis(differences) {
            const card = document.createElement('div');
            card.className = 'analytics-card';
            card.innerHTML = `<div class="card-title">Timeline –∞–Ω–∞–ª—ñ–∑</div>`;

            // Try to detect timestamp fields
            const timeFields = ['timestamp', 'createdAt', 'updatedAt', 'date', 'time'];
            const timelineData = [];

            differences.forEach(diff => {
                timeFields.forEach(field => {
                    if (diff.path.toLowerCase().includes(field.toLowerCase())) {
                        let timeValue = null;
                        try {
                            timeValue = new Date(diff.newValue || diff.oldValue);
                            if (!isNaN(timeValue.getTime())) {
                                timelineData.push({
                                    time: timeValue,
                                    type: diff.type,
                                    path: diff.path
                                });
                            }
                        } catch (e) {
                            // Ignore invalid dates
                        }
                    }
                });
            });

            if (timelineData.length > 0) {
                const timelineContainer = document.createElement('div');
                timelineContainer.className = 'timeline-container';
                
                timelineData.sort((a, b) => a.time - b.time);
                const minTime = timelineData[0].time.getTime();
                const maxTime = timelineData[timelineData.length - 1].time.getTime();
                const timeRange = maxTime - minTime || 1;

                const track = document.createElement('div');
                track.className = 'timeline-track';

                timelineData.forEach(item => {
                    const position = ((item.time.getTime() - minTime) / timeRange) * 100;
                    const timelineItem = document.createElement('div');
                    timelineItem.className = `timeline-item ${getMinimapClass(item.type)}`;
                    timelineItem.style.left = `${position}%`;
                    timelineItem.style.width = '8px';
                    timelineItem.title = `${item.path}: ${item.time.toLocaleDateString()}`;
                    track.appendChild(timelineItem);
                });

                timelineContainer.appendChild(track);
                card.appendChild(timelineContainer);
            } else {
                card.innerHTML += '<p style="text-align: center; color: #666; margin: 20px 0;">–ù–µ –≤–∏—è–≤–ª–µ–Ω–æ –ø–æ–ª—ñ–≤ –∑ –¥–∞—Ç–∞–º–∏ –¥–ª—è timeline –∞–Ω–∞–ª—ñ–∑—É</p>';
            }

            return card;
        }

        function createStructureHeatmap(differences, sourceJson, targetJson) {
            const container = document.createElement('div');
            container.innerHTML = '<div class="card-title">üî• Heatmap –∑–º—ñ–Ω –ø–æ —Å—Ç—Ä—É–∫—Ç—É—Ä—ñ</div>';
            
            // Create a simplified heatmap based on path frequency
            const pathMap = {};
            differences.forEach(diff => {
                const pathParts = diff.path.split('.');
                pathParts.forEach((part, index) => {
                    const partialPath = pathParts.slice(0, index + 1).join('.');
                    pathMap[partialPath] = (pathMap[partialPath] || 0) + 1;
                });
            });

            const maxChanges = Math.max(...Object.values(pathMap));
            const heatmapContainer = document.createElement('div');
            heatmapContainer.className = 'heatmap-container';
            
            // Determine grid size based on data complexity
            const uniquePaths = Object.keys(pathMap);
            const gridSize = Math.min(20, Math.max(8, Math.ceil(Math.sqrt(uniquePaths.length))));
            heatmapContainer.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;

            uniquePaths.slice(0, gridSize * gridSize).forEach(path => {
                const intensity = Math.ceil((pathMap[path] / maxChanges) * 5);
                const cell = document.createElement('div');
                cell.className = `heatmap-cell intensity-${intensity}`;
                cell.title = `${path}: ${pathMap[path]} –∑–º—ñ–Ω`;
                cell.addEventListener('click', () => {
                    // Filter table to show only this path
                    filterTableByPath(path);
                });
                heatmapContainer.appendChild(cell);
            });

            container.appendChild(heatmapContainer);
            return container;
        }

        function filterTableByPath(path) {
            const searchInput = document.getElementById('searchInput');
            if (searchInput) {
                searchInput.value = path;
                searchInput.dispatchEvent(new Event('input'));
                showToast(`–§—ñ–ª—å—Ç—Ä–æ–≤–∞–Ω–æ –ø–æ —à–ª—è—Ö—É: ${path}`, 'info');
            }
        }

        // Export analytics functions
        function exportAnalytics(format) {
            const analytics = generateAnalyticsData();
            
            if (format === 'excel') {
                exportToExcel(analytics);
            } else if (format === 'detailed-csv') {
                exportDetailedCSV(analytics);
            }
        }

        function generateAnalyticsData() {
            return {
                summary: {
                    totalChanges: globalDifferences.length,
                    changeTypes: getChangeTypeCounts(),
                    complexity: calculateComplexityScore(),
                    timestamp: new Date().toISOString()
                },
                details: globalDifferences.map(diff => ({
                    ...diff,
                    importance: getImportanceLevel(diff),
                    pathDepth: diff.path.split('.').length
                }))
            };
        }

        function getChangeTypeCounts() {
            const counts = {};
            globalDifferences.forEach(diff => {
                counts[diff.type] = (counts[diff.type] || 0) + 1;
            });
            return counts;
        }

        function calculateComplexityScore() {
            // Simple complexity score based on number of changes and path depths
            const avgDepth = globalDifferences.reduce((sum, diff) => 
                sum + diff.path.split('.').length, 0) / globalDifferences.length;
            return Math.round(globalDifferences.length * avgDepth / 10);
        }

        function exportToExcel(analytics) {
            // Create CSV that Excel can open with analytics data
            const csvContent = [
                'JSON Comparator - –î–µ—Ç–∞–ª—å–Ω–∏–π –∞–Ω–∞–ª—ñ—Ç–∏—á–Ω–∏–π –∑–≤—ñ—Ç',
                `–î–∞—Ç–∞ —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è: ${new Date().toLocaleDateString('uk-UA')}`,
                `–ó–∞–≥–∞–ª—å–Ω–∞ –∫—ñ–ª—å–∫—ñ—Å—Ç—å –∑–º—ñ–Ω: ${analytics.summary.totalChanges}`,
                `–û—Ü—ñ–Ω–∫–∞ —Å–∫–ª–∞–¥–Ω–æ—Å—Ç—ñ: ${analytics.summary.complexity}`,
                '',
                '–†–æ–∑–ø–æ–¥—ñ–ª –ø–æ —Ç–∏–ø–∞—Ö –∑–º—ñ–Ω:',
                ...Object.entries(analytics.summary.changeTypes).map(([type, count]) => `${type}: ${count}`),
                '',
                '–î–µ—Ç–∞–ª—å–Ω—ñ –¥–∞–Ω—ñ:',
                '–¢–∏–ø,–®–ª—è—Ö,–ü—Ä–∏—á–∏–Ω–∞,–°—Ç–∞—Ä–µ –∑–Ω–∞—á–µ–Ω–Ω—è,–ù–æ–≤–µ –∑–Ω–∞—á–µ–Ω–Ω—è,–í–∞–∂–ª–∏–≤—ñ—Å—Ç—å,–ì–ª–∏–±–∏–Ω–∞ —à–ª—è—Ö—É',
                ...analytics.details.map(diff => [
                    diff.type,
                    diff.path,
                    diff.reason,
                    diff.oldValue || '',
                    diff.newValue || '',
                    diff.importance,
                    diff.pathDepth
                ].map(field => `"${String(field).replace(/"/g, '""')}"`).join(','))
            ].join('\n');

            downloadFile(csvContent, 'json-comparator-analytics.csv', 'text/csv;charset=utf-8;');
            showToast('Excel –∞–Ω–∞–ª—ñ—Ç–∏—á–Ω–∏–π –∑–≤—ñ—Ç –µ–∫—Å–ø–æ—Ä—Ç–æ–≤–∞–Ω–æ!', 'success');
        }

        function exportDetailedCSV(analytics) {
            const csvContent = [
                '–¢–∏–ø,–®–ª—è—Ö,–ü—Ä–∏—á–∏–Ω–∞,–°—Ç–∞—Ä–µ –∑–Ω–∞—á–µ–Ω–Ω—è,–ù–æ–≤–µ –∑–Ω–∞—á–µ–Ω–Ω—è,–í–∞–∂–ª–∏–≤—ñ—Å—Ç—å,–ì–ª–∏–±–∏–Ω–∞ —à–ª—è—Ö—É,–ß–∞—Å —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è',
                ...analytics.details.map(diff => [
                    diff.type,
                    diff.path, 
                    diff.reason,
                    diff.oldValue || '',
                    diff.newValue || '',
                    diff.importance,
                    diff.pathDepth,
                    analytics.summary.timestamp
                ].map(field => `"${String(field).replace(/"/g, '""')}"`).join(','))
            ].join('\n');

            downloadFile(csvContent, 'json-comparator-detailed.csv', 'text/csv;charset=utf-8;');
            showToast('–î–µ—Ç–∞–ª—å–Ω–∏–π CSV –∑–≤—ñ—Ç –µ–∫—Å–ø–æ—Ä—Ç–æ–≤–∞–Ω–æ!', 'success');
        }

        function generateInsights() {
            const insights = [];
            const analytics = generateAnalyticsData();
            
            // Generate automated insights
            if (analytics.summary.totalChanges > 50) {
                insights.push('üîç –í–µ–ª–∏–∫–∞ –∫—ñ–ª—å–∫—ñ—Å—Ç—å –∑–º—ñ–Ω –≤–∏—è–≤–ª–µ–Ω–∞ - —Ä–µ–∫–æ–º–µ–Ω–¥—É—î—Ç—å—Å—è –¥–µ—Ç–∞–ª—å–Ω–∏–π –∞–Ω–∞–ª—ñ–∑');
            }
            
            if (analytics.summary.complexity > 20) {
                insights.push('‚ö†Ô∏è –í–∏—Å–æ–∫–∞ —Å–∫–ª–∞–¥–Ω—ñ—Å—Ç—å –∑–º—ñ–Ω - –º–æ–∂–µ –ø–æ—Ç—Ä–µ–±—É–≤–∞—Ç–∏ –¥–æ–¥–∞—Ç–∫–æ–≤–æ–≥–æ —Ç–µ—Å—Ç—É–≤–∞–Ω–Ω—è');
            }

            const changeTypes = Object.keys(analytics.summary.changeTypes);
            if (changeTypes.includes('TypeChanged')) {
                insights.push('üîÑ –í–∏—è–≤–ª–µ–Ω–æ –∑–º—ñ–Ω–∏ —Ç–∏–ø—ñ–≤ –¥–∞–Ω–∏—Ö - –ø–µ—Ä–µ–≤—ñ—Ä—Ç–µ —Å—É–º—ñ—Å–Ω—ñ—Å—Ç—å');
            }

            if (changeTypes.includes('SchemaError')) {
                insights.push('‚ùå –í–∏—è–≤–ª–µ–Ω–æ –ø–æ–º–∏–ª–∫–∏ —Å—Ö–µ–º–∏ - –Ω–µ–æ–±—Ö—ñ–¥–Ω–µ –≤–∏–ø—Ä–∞–≤–ª–µ–Ω–Ω—è');
            }

            const pathDepths = analytics.details.map(d => d.pathDepth);
            const maxDepth = Math.max(...pathDepths);
            if (maxDepth > 6) {
                insights.push('üìä –ì–ª–∏–±–æ–∫–∞ –≤–∫–ª–∞–¥–µ–Ω—ñ—Å—Ç—å –∑–º—ñ–Ω - —Ä–µ–∫–æ–º–µ–Ω–¥—É—î—Ç—å—Å—è —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏');
            }

            showInsightsModal(insights);
        }

        function showInsightsModal(insights) {
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h2>üí° –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω—ñ —ñ–Ω—Å–∞–π—Ç–∏</h2>
                        <button class="modal-close">&times;</button>
                    </div>
                    <div class="modal-body">
                        ${insights.length > 0 ? 
                            insights.map(insight => `<p>‚Ä¢ ${insight}</p>`).join('') :
                            '<p>üòä –ù–µ –≤–∏—è–≤–ª–µ–Ω–æ –∫—Ä–∏—Ç–∏—á–Ω–∏—Ö –ø—Ä–æ–±–ª–µ–º. –ó–º—ñ–Ω–∏ –≤–∏–≥–ª—è–¥–∞—é—Ç—å —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∏–º–∏.</p>'
                        }
                    </div>
                </div>
            `;

            modal.querySelector('.modal-close').addEventListener('click', () => {
                modal.remove();
            });

            modal.addEventListener('click', (e) => {
                if (e.target === modal) modal.remove();
            });

            document.body.appendChild(modal);
            showToast('–Ü–Ω—Å–∞–π—Ç–∏ –∑–≥–µ–Ω–µ—Ä–æ–≤–∞–Ω–æ!', 'info');
        }

        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        // Setup view mode controls (table/grouped/tree views)
        function setupViewModeControls(differences) {
            const viewButtons = document.querySelectorAll('.view-toggle button');
            const tableContainer = document.getElementById('table-container');
            
            viewButtons.forEach(button => {
                button.addEventListener('click', () => {
                    // Remove active class from all buttons
                    viewButtons.forEach(btn => btn.classList.remove('active'));
                    // Add active class to clicked button
                    button.classList.add('active');
                    
                    const viewMode = button.dataset.view;
                    currentViewMode = viewMode;
                    
                    // Clear current content
                    tableContainer.innerHTML = '';
                    
                    switch (viewMode) {
                        case 'table':
                            // Re-render normal table (this is already handled by renderInteractiveTable)
                            setTimeout(() => {
                                const applyFiltersFunc = window.currentApplyFiltersAndSort;
                                if (applyFiltersFunc) applyFiltersFunc();
                            }, 10);
                            break;
                            
                        case 'grouped':
                            const groupedView = createGroupedDiffView(differences);
                            tableContainer.appendChild(groupedView);
                            showToast('–ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–æ –Ω–∞ –≥—Ä—É–ø–æ–≤–∞–Ω–∏–π –≤–∏–≥–ª—è–¥', 'info');
                            break;
                            
                        case 'tree':
                            const treeView = createJsonTreeView(differences);
                            tableContainer.appendChild(treeView);
                            showToast('–ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–æ –Ω–∞ –¥–µ—Ä–µ–≤–æ–≤–∏–¥–Ω–∏–π –≤–∏–≥–ª—è–¥', 'info');
                            break;
                    }
                });
            });
        }

        // Create JSON tree view for differences
        function createJsonTreeView(differences) {
            const container = document.createElement('div');
            container.className = 'json-tree-view';
            container.innerHTML = '<div class="card-title">üå≥ JSON —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –∑ –≤–∏–¥—ñ–ª–µ–Ω–Ω—è–º –∑–º—ñ–Ω</div>';
            
            // Build tree structure from differences
            const pathTree = {};
            differences.forEach(diff => {
                const pathParts = diff.path.split('.');
                let current = pathTree;
                
                pathParts.forEach((part, index) => {
                    if (!current[part]) {
                        current[part] = {
                            children: {},
                            differences: [],
                            isLeaf: index === pathParts.length - 1
                        };
                    }
                    
                    if (index === pathParts.length - 1) {
                        current[part].differences.push(diff);
                    }
                    
                    current = current[part].children;
                });
            });

            function renderTreeNode(node, nodeKey, level = 0) {
                const nodeDiv = document.createElement('div');
                nodeDiv.className = 'tree-node';
                nodeDiv.style.marginLeft = `${level * 20}px`;
                
                const hasChildren = Object.keys(node.children).length > 0;
                const hasDifferences = node.differences.length > 0;
                
                let nodeClass = 'tree-node-normal';
                if (hasDifferences) {
                    const firstDiff = node.differences[0];
                    nodeClass = `tree-node-${getMinimapClass(firstDiff.type)}`;
                }
                
                nodeDiv.innerHTML = `
                    <div class="tree-node-header ${nodeClass}">
                        ${hasChildren ? '<span class="tree-toggle">‚ñº</span>' : '<span class="tree-spacer">‚Ä¢</span>'}
                        <span class="tree-key">${nodeKey}</span>
                        ${hasDifferences ? `<span class="tree-diff-count">(${node.differences.length})</span>` : ''}
                    </div>
                `;

                const nodeContent = document.createElement('div');
                nodeContent.className = 'tree-node-content';
                
                // Add differences for this node
                if (hasDifferences) {
                    node.differences.forEach(diff => {
                        const diffDiv = document.createElement('div');
                        diffDiv.className = `tree-diff-item importance-${getImportanceLevel(diff)}`;
                        diffDiv.innerHTML = `
                            <span class="diff-type">${diff.type}</span>
                            <span class="diff-reason">${escapeHtml(diff.reason)}</span>
                        `;
                        nodeContent.appendChild(diffDiv);
                    });
                }
                
                // Add child nodes
                Object.keys(node.children).forEach(childKey => {
                    const childNode = renderTreeNode(node.children[childKey], childKey, level + 1);
                    nodeContent.appendChild(childNode);
                });
                
                if (hasChildren) {
                    const toggle = nodeDiv.querySelector('.tree-toggle');
                    toggle.addEventListener('click', () => {
                        nodeContent.classList.toggle('collapsed');
                        toggle.textContent = nodeContent.classList.contains('collapsed') ? '‚ñ∂' : '‚ñº';
                    });
                }
                
                nodeDiv.appendChild(nodeContent);
                return nodeDiv;
            }

            // Render root nodes
            Object.keys(pathTree).forEach(rootKey => {
                const rootNode = renderTreeNode(pathTree[rootKey], rootKey);
                container.appendChild(rootNode);
            });

            return container;
        }

        // Function to parse JSON content from textarea with enhanced error handling
        function parseJson(text, dropZone, errorEl) {
                try {
                    if (!text || text.trim() === '') {
                        errorEl.style.display = 'none';
                        dropZone.classList.remove('invalid');
                        return null;
                    }

                    // Check size limits (10MB as string length)
                    const MAX_JSON_SIZE = 10 * 1024 * 1024; // 10MB
                    if (text.length > MAX_JSON_SIZE) {
                        throw new Error(`JSON –∑–∞–Ω–∞–¥—Ç–æ –≤–µ–ª–∏–∫–∏–π (${(text.length / 1024 / 1024).toFixed(1)}MB). –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∏–π —Ä–æ–∑–º—ñ—Ä: ${MAX_JSON_SIZE / 1024 / 1024}MB`);
                    }

                    // Try to parse with timeout simulation for large objects
                    let parsed;
                    const startTime = Date.now();
                    
                    try {
                        parsed = JSON.parse(text);
                    } catch (parseError) {
                        if (parseError.message.includes('Unexpected token')) {
                            throw new Error(`–°–∏–Ω—Ç–∞–∫—Å–∏—á–Ω–∞ –ø–æ–º–∏–ª–∫–∞ JSON –Ω–∞ –ø–æ–∑–∏—Ü—ñ—ó ${getJsonErrorPosition(text, parseError)}: ${parseError.message}`);
                        }
                        throw parseError;
                    }

                    const parseTime = Date.now() - startTime;
                    if (parseTime > 5000) { // 5 seconds warning
                        console.warn(`JSON parsing took ${parseTime}ms, consider optimizing`);
                    }

                    // Validate structure for non-schema modes
                    if (currentMode !== 'schema' && (typeof parsed !== 'object' || parsed === null)) {
                        throw new Error("–í—Ö—ñ–¥–Ω—ñ –¥–∞–Ω—ñ –ø–æ–≤–∏–Ω–Ω—ñ –±—É—Ç–∏ JSON-–æ–±'—î–∫—Ç–æ–º –∞–±–æ –º–∞—Å–∏–≤–æ–º.");
                    }

                    // Additional validation for very deep nesting
                    const maxDepth = 50;
                    if (getObjectDepth(parsed) > maxDepth) {
                        console.warn(`JSON –º–∞—î –≥–ª–∏–±–æ–∫—É –≤–∫–ª–∞–¥–µ–Ω—ñ—Å—Ç—å (>${maxDepth} —Ä—ñ–≤–Ω—ñ–≤), —Ü–µ –º–æ–∂–µ –≤–ø–ª–∏–Ω—É—Ç–∏ –Ω–∞ –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å`);
                    }

                    errorEl.style.display = 'none';
                    dropZone.classList.remove('invalid');
                    updateAriaInvalid(dropZone.querySelector('textarea'), false);
                    return parsed;
                } catch (jsonError) {
                    const errorMessage = jsonError.message || '–ù–µ–≤—ñ–¥–æ–º–∞ –ø–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –ø–∞—Ä—Å–∏–Ω–≥—É JSON';
                    errorEl.textContent = `–ü–æ–º–∏–ª–∫–∞: ${errorMessage}`;
                    errorEl.style.display = 'block';
                    dropZone.classList.add('invalid');
                    updateAriaInvalid(dropZone.querySelector('textarea'), true);
                    announceToScreenReader(`–ü–æ–º–∏–ª–∫–∞ –≤–∞–ª—ñ–¥–∞—Ü—ñ—ó JSON: ${errorMessage}`, 'assertive');
                    return null;
                }
            }

            // Helper function to get approximate error position in JSON
            function getJsonErrorPosition(text, error) {
                const match = error.message.match(/position (\d+)/);
                if (match) {
                    const pos = parseInt(match[1]);
                    const lines = text.substring(0, pos).split('\n');
                    return `—Ä—è–¥–æ–∫ ${lines.length}, —Å–∏–º–≤–æ–ª ${lines[lines.length - 1].length + 1}`;
                }
                return '–Ω–µ–≤—ñ–¥–æ–º–∞ –ø–æ–∑–∏—Ü—ñ—è';
            }

            // Helper function to calculate object depth
            function getObjectDepth(obj, currentDepth = 0) {
                if (typeof obj !== 'object' || obj === null || currentDepth > 100) {
                    return currentDepth;
                }
                
                let maxDepth = currentDepth;
                for (const key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        const depth = getObjectDepth(obj[key], currentDepth + 1);
                        maxDepth = Math.max(maxDepth, depth);
                    }
                }
                return maxDepth;
            }

            // Function to setup drag-and-drop functionality for a drop zone
            function setupDropZone(dropZone, textArea, fileNameEl, errorEl, fileContentCallback) {
                textArea.addEventListener('input', () => {
                    try {
                        const rawContent = textArea.value;
                        
                        // Sanitize manual input
                        const content = sanitizeInput(rawContent);
                        
                        // Update textarea if content was sanitized
                        if (content !== rawContent) {
                            textArea.value = content;
                            showToast('–í–≤–µ–¥–µ–Ω–∏–π —Ç–µ–∫—Å—Ç –±—É–ª–æ –æ—á–∏—â–µ–Ω–æ –≤—ñ–¥ –Ω–µ–±–µ–∑–ø–µ—á–Ω–∏—Ö –µ–ª–µ–º–µ–Ω—Ç—ñ–≤.', 'info');
                        }
                        
                        fileContentCallback(content);
                        const parsed = parseJson(content, dropZone, errorEl);
                        if (!parsed && content.trim() !== '') {
                            showToast(`–ü–æ–º–∏–ª–∫–∞ —É —Ñ–∞–π–ª—ñ: ${fileNameEl.textContent || dropZone.querySelector('textarea').placeholder.split(' ')[2]}. ${errorEl.textContent}`, 'error');
                        }
                        fileNameEl.textContent = '';
                        checkFilesReady();
                    } catch (error) {
                        console.error('Error processing input:', error);
                        showToast('–ü–æ–º–∏–ª–∫–∞ –æ–±—Ä–æ–±–∫–∏ –≤–≤–µ–¥–µ–Ω–∏—Ö –¥–∞–Ω–∏—Ö.', 'error');
                    }
                });

                dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('dragover'); });
                dropZone.addEventListener('dragleave', e => { e.preventDefault(); dropZone.classList.remove('dragover'); });
                dropZone.addEventListener('drop', e => {
                    e.preventDefault();
                    dropZone.classList.remove('dragover');
                    const file = e.dataTransfer.files[0];
                    if (!file) return;

                    if (file.size > 5 * 1024 * 1024) {
                        showToast("–§–∞–π–ª –∑–∞–Ω–∞–¥—Ç–æ –≤–µ–ª–∏–∫–∏–π. –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∏–π —Ä–æ–∑–º—ñ—Ä - 5MB.", 'error');
                        return;
                    }

                    try {
                        // Enhanced file validation
                        if (!file.type.includes('json') && !file.name.endsWith('.json') && !file.name.endsWith('.txt')) {
                            throw new Error('–ë—É–¥—å –ª–∞—Å–∫–∞, –ø–µ—Ä–µ—Ç—è–≥–Ω—ñ—Ç—å JSON –∞–±–æ —Ç–µ–∫—Å—Ç–æ–≤–∏–π —Ñ–∞–π–ª.');
                        }

                        fileNameEl.textContent = file.name;
                        const reader = new FileReader();
                        
                        reader.onload = (event) => {
                            try {
                                const rawContent = event.target.result;
                                
                                // Validate and sanitize file content
                                const content = validateFileContent(rawContent, file.name);
                                
                                textArea.value = content;
                                fileContentCallback(content);
                                
                                const parsed = parseJson(content, dropZone, errorEl);
                                if (!parsed && content.trim() !== '') {
                                    showToast(`–ü–æ–º–∏–ª–∫–∞ —É —Ñ–∞–π–ª—ñ '${file.name}'. ${errorEl.textContent}`, 'error');
                                } else {
                                    showToast(`–§–∞–π–ª '${file.name}' –±–µ–∑–ø–µ—á–Ω–æ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ.`, 'success');
                                }
                                checkFilesReady();
                            } catch (validationError) {
                                errorEl.textContent = `–ü–æ–º–∏–ª–∫–∞ –≤–∞–ª—ñ–¥–∞—Ü—ñ—ó —Ñ–∞–π–ª—É: ${validationError.message}`;
                                errorEl.style.display = 'block';
                                dropZone.classList.add('invalid');
                                showToast(`–§–∞–π–ª '${file.name}' –≤—ñ–¥—Ö–∏–ª–µ–Ω–æ: ${validationError.message}`, 'error');
                                fileNameEl.textContent = '';
                                textArea.value = '';
                                fileContentCallback(null);
                                checkFilesReady();
                            }
                        };
                        
                        reader.onerror = () => {
                            showToast(`–ü–æ–º–∏–ª–∫–∞ —á–∏—Ç–∞–Ω–Ω—è —Ñ–∞–π–ª—É '${file.name}'.`, 'error');
                            fileNameEl.textContent = '';
                            textArea.value = '';
                            fileContentCallback(null);
                            checkFilesReady();
                        };
                        
                        reader.readAsText(file);
                    } catch (error) {
                        showToast(error.message, 'error');
                        fileNameEl.textContent = '';
                        textArea.value = '';
                        fileContentCallback(null);
                        checkFilesReady();
                    }
                });
            }

        // Function to check if files are ready for comparison
        function checkFilesReady() {
            let isReady = false;
            const sourceValid = (!document.getElementById('sourceError').style.display || document.getElementById('sourceError').style.display === 'none') && (sourceFileContent !== null && sourceFileContent.trim() !== '');
            const targetValid = (!document.getElementById('targetError').style.display || document.getElementById('targetError').style.display === 'none') && (targetFileContent !== null && targetFileContent.trim() !== '');
            const schemaValid = (!document.getElementById('schemaError').style.display || document.getElementById('schemaError').style.display === 'none') && (schemaFileContent !== null && schemaFileContent.trim() !== '');

            if (currentMode === 'schema') {
                isReady = schemaValid && targetValid && isAjvAvailable();
            } else {
                isReady = sourceValid && targetValid;
            }
            const compareBtn = document.getElementById('compareBtn');
            if (compareBtn) {
                compareBtn.disabled = !isReady;
            }
        }

        // --- DOMContentLoaded initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            // –î—ñ–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ AJV –ø—Ä–∏ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—ñ —Å—Ç–æ—Ä—ñ–Ω–∫–∏
            console.log('AJV Library Check on DOMContentLoaded:', {
                'typeof Ajv': typeof Ajv,
                'typeof window.Ajv': typeof window.Ajv,
                'isAjvAvailable()': isAjvAvailable()
            });

            // –Ø–∫—â–æ AJV –Ω–µ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–∞, —Å–ø—Ä–æ–±—É—î–º–æ –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ —ó—ó —â–µ —Ä–∞–∑
            if (!isAjvAvailable()) {
                console.warn('AJV not available, attempting to load via alternative method...');
                const fallbackScript = document.createElement('script');
                fallbackScript.src = 'https://unpkg.com/ajv@8.17.1/dist/ajv.bundle.js';
                                fallbackScript.onload = function() {
                    console.log('AJV fallback loaded successfully');
                    console.log('üéØ JSON Schema validation is now available with enhanced error reporting');
                    showToast('‚úÖ AJV –±—ñ–±–ª—ñ–æ—Ç–µ–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–∞ —É—Å–ø—ñ—à–Ω–æ!', 'success');
                    checkFilesReady(); // –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –≥–æ—Ç–æ–≤–Ω—ñ—Å—Ç—å –ø—ñ—Å–ª—è –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è
                };
                fallbackScript.onerror = function() {
                    console.error('All AJV loading methods failed');
                    window.AjvLoadError = true;
                };
                document.head.appendChild(fallbackScript);
            }
            // --- DOM Elements ---
            const dropZone1 = document.getElementById('dropZone1');
            const dropZone2 = document.getElementById('dropZone2');
            const dropZoneSchema = document.getElementById('dropZoneSchema');
            const compareBtn = document.getElementById('compareBtn');
            const exportBtn = document.getElementById('exportBtn');
            const resultsContainer = document.getElementById('results');
            const settingsBtn = document.getElementById('settingsBtn');
            const settingsModal = document.getElementById('settingsModal');
            const closeSettingsModalBtn = document.getElementById('closeSettingsModal');
            const saveSettingsBtn = document.getElementById('saveSettingsBtn');
            const clearAllBtn = document.getElementById('clearAllBtn');
            const copyResultsBtn = document.getElementById('copyResultsBtn');
            const widthToggleBtn = document.getElementById('widthToggleBtn');
            const widthEnterIcon = document.getElementById('width-enter-icon');
            const widthExitIcon = document.getElementById('width-exit-icon');

            // --- Initial setup ---
            loadSettings();
            updateUiForMode();
            initializeTooltips();
            addKeyboardSupport();
            setupScrollToTop();

            // --- Event Listeners ---
            if (settingsBtn) {
                settingsBtn.addEventListener('click', () => { 
                    settingsModal.style.display = 'flex'; 
                    initializeTooltips(); 
                });
            }
            
            if (closeSettingsModalBtn) {
                closeSettingsModalBtn.addEventListener('click', () => { 
                    settingsModal.style.display = 'none'; 
                });
            }
            
            if (saveSettingsBtn) {
                saveSettingsBtn.addEventListener('click', saveSettings);
            }
            
            window.addEventListener('click', (event) => {
                if (event.target === settingsModal) {
                    settingsModal.style.display = 'none';
                }
            });
            
            const themeToggle = document.getElementById('checkbox');
            if (themeToggle) {
                themeToggle.addEventListener('change', () => {
                    document.body.classList.toggle('dark-mode');
                    localStorage.setItem('theme', document.body.classList.contains('dark-mode') ? 'dark' : 'light');
                });

                // Re-apply theme on load
                if (localStorage.getItem('theme') === 'dark') {
                    document.body.classList.add('dark-mode');
                    themeToggle.checked = true;
                }
            }

            // --- Initial setup for drop zones (needs to be inside DOMContentLoaded as it accesses DOM elements)
            setupDropZone(dropZone1, document.getElementById('sourceText'), document.getElementById('fileName1'), document.getElementById('sourceError'), content => sourceFileContent = content);
            setupDropZone(dropZone2, document.getElementById('targetText'), document.getElementById('fileName2'), document.getElementById('targetError'), content => targetFileContent = content);
            setupDropZone(dropZoneSchema, document.getElementById('schemaText'), document.getElementById('fileNameSchema'), document.getElementById('schemaError'), content => schemaFileContent = content);

            // --- Setup example schema insertion ---
            const insertExampleSchemaBtn = document.getElementById('insertExampleSchema');
            if (insertExampleSchemaBtn) {
                insertExampleSchemaBtn.addEventListener('click', () => {
                    const schemaTextArea = document.getElementById('schemaText');
                    const exampleSchemaText = document.getElementById('exampleSchemaText');
                    
                    if (schemaTextArea && exampleSchemaText) {
                        // Clear any existing error states
                        const schemaError = document.getElementById('schemaError');
                        if (schemaError) {
                            schemaError.style.display = 'none';
                        }
                        const dropZoneSchema = document.getElementById('dropZoneSchema');
                        if (dropZoneSchema) {
                            dropZoneSchema.classList.remove('invalid');
                        }
                        
                        // Insert the example schema
                        schemaTextArea.value = exampleSchemaText.textContent.trim();
                        schemaFileContent = schemaTextArea.value;
                        
                        // Update file name display
                        const fileNameSchema = document.getElementById('fileNameSchema');
                        if (fileNameSchema) {
                            fileNameSchema.textContent = 'üìã –ü—Ä–∏–∫–ª–∞–¥ —Å—Ö–µ–º–∏ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞';
                        }
                        
                        // Check if files are ready for comparison
                        checkFilesReady();
                        
                        // Show success message
                        showToast('‚úÖ –ü—Ä–∏–∫–ª–∞–¥ —Å—Ö–µ–º–∏ –≤—Å—Ç–∞–≤–ª–µ–Ω–æ —É—Å–ø—ñ—à–Ω–æ!', 'success');
                        
                        // Close the details element
                        const detailsElement = insertExampleSchemaBtn.closest('details');
                        if (detailsElement) {
                            detailsElement.open = false;
                        }
                    }
                });
            }

            // Add event listeners for mode changes
            document.querySelectorAll('input[name="compareMode"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    currentMode = e.target.value;
                    updateUiForMode();
                    checkFilesReady();
                });
            });

            // Event listener for compare button with enhanced error handling
            compareBtn.addEventListener('click', () => {
                showLoader();
                
                // Use setTimeout to avoid blocking UI and enable timeout handling
                setTimeout(async () => {
                    const COMPARISON_TIMEOUT = 30000; // 30 seconds
                    let timeoutId;
                    
                    try {
                        // Set up timeout for long operations
                        const timeoutPromise = new Promise((_, reject) => {
                            timeoutId = setTimeout(() => {
                                reject(new Error('–ß–∞—Å –æ—á—ñ–∫—É–≤–∞–Ω–Ω—è –æ–ø–µ—Ä–∞—Ü—ñ—ó –≤–∏—á–µ—Ä–ø–∞–Ω–æ (30 —Å–µ–∫—É–Ω–¥). –°–ø—Ä–æ–±—É–π—Ç–µ –∑ –º–µ–Ω—à–∏–º–∏ —Ñ–∞–π–ª–∞–º–∏.'));
                            }, COMPARISON_TIMEOUT);
                        });

                        const comparisonPromise = new Promise((resolve, reject) => {
                            try {
                                let sourceJson = null;
                                let targetJson = null;
                                let schemaJson = null;

                                if (currentMode === 'schema') {
                                    schemaJson = parseJson(schemaFileContent, dropZoneSchema, document.getElementById('schemaError'));
                                    targetJson = parseJson(targetFileContent, dropZone2, document.getElementById('targetError'));
                                } else {
                                    sourceJson = parseJson(sourceFileContent, dropZone1, document.getElementById('sourceError'));
                                    targetJson = parseJson(targetFileContent, dropZone2, document.getElementById('targetError'));
                                }

                                let canProceed = false;
                                if (currentMode === 'schema') {
                                    canProceed = schemaJson && targetJson;
                                } else {
                                    canProceed = sourceJson && targetJson;
                                }

                                if (!canProceed) {
                                    reject(new Error("–ë—É–¥—å –ª–∞—Å–∫–∞, –ø–µ—Ä–µ–≤—ñ—Ä—Ç–µ –≤—Ö—ñ–¥–Ω—ñ –¥–∞–Ω—ñ. –û–¥–∏–Ω –∞–±–æ –¥–µ–∫—ñ–ª—å–∫–∞ —Ñ–∞–π–ª—ñ–≤ –Ω–µ —î –≤–∞–ª—ñ–¥–Ω–∏–º–∏ JSON."));
                                    return;
                                }

                                // Estimate complexity and warn user
                                const complexity = estimateComplexity(sourceJson, targetJson, schemaJson);
                                if (complexity > 100000) {
                                    console.warn(`High complexity operation detected: ${complexity}. This may take some time.`);
                                }

                                globalDifferences = [];
                                const startTime = Date.now();

                                if (currentMode === 'direct') {
                                    globalDifferences = findDifferences(sourceJson, targetJson, false, '$', settings);
                                    renderReport(globalDifferences, sourceJson, targetJson);
                                } else if (currentMode === 'keys') {
                                    globalDifferences = findDifferences(sourceJson, targetJson, true, '$', settings);
                                    renderReport(globalDifferences, sourceJson, targetJson);
                                } else if (currentMode === 'schema') {
                                    // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—ñ AJV –ø–µ—Ä–µ–¥ –≤–∞–ª—ñ–¥–∞—Ü—ñ—î—é
                                    if (!isAjvAvailable()) {
                                        reject(new Error('AJV –±—ñ–±–ª—ñ–æ—Ç–µ–∫–∞ –Ω–µ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–∞. –ü–µ—Ä–µ–∑–∞–≤–∞–Ω—Ç–∞–∂—Ç–µ —Å—Ç–æ—Ä—ñ–Ω–∫—É —Ç–∞ –ø–µ—Ä–µ–≤—ñ—Ä—Ç–µ —ñ–Ω—Ç–µ—Ä–Ω–µ—Ç-–∑\'—î–¥–Ω–∞–Ω–Ω—è.'));
                                        return;
                                    }
                                    globalDifferences = validateWithSchema(targetJson, schemaJson);
                                    renderReport(globalDifferences, schemaJson, targetJson);
                                }

                                const duration = Date.now() - startTime;
                                console.log(`Comparison completed in ${duration}ms`);
                                
                                resolve();
                            } catch (error) {
                                reject(error);
                            }
                        });

                        // Race between comparison and timeout
                        await Promise.race([comparisonPromise, timeoutPromise]);
                        
                        showToast(`–ü–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è –∑–∞–≤–µ—Ä—à–µ–Ω–æ. –ó–Ω–∞–π–¥–µ–Ω–æ ${globalDifferences.length} –≤—ñ–¥–º—ñ–Ω–Ω–æ—Å—Ç–µ–π.`, 'success');
                        
                    } catch (e) {
                        console.error("–ü–æ–º–∏–ª–∫–∞ –∞–Ω–∞–ª—ñ–∑—É/–≤–∞–ª—ñ–¥–∞—Ü—ñ—ó:", e);
                        
                        let errorMessage = e.message;
                        if (e.message.includes('timeout') || e.message.includes('–ß–∞—Å –æ—á—ñ–∫—É–≤–∞–Ω–Ω—è')) {
                            errorMessage = '–û–ø–µ—Ä–∞—Ü—ñ—è –∑–∞–π–Ω—è–ª–∞ –∑–∞–Ω–∞–¥—Ç–æ –±–∞–≥–∞—Ç–æ —á–∞—Å—É. –°–ø—Ä–æ–±—É–π—Ç–µ –∑ –º–µ–Ω—à–∏–º–∏ —Ñ–∞–π–ª–∞–º–∏ –∞–±–æ —Å–ø—Ä–æ—Å—Ç—ñ—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—É JSON.';
                        } else if (e.message.includes('memory') || e.message.includes("–ø–∞–º'—è—Ç—å")) {
                            errorMessage = '–ù–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ –ø–∞–º\'—è—Ç—ñ –¥–ª—è –æ–±—Ä–æ–±–∫–∏ —Ç–∞–∫–∏—Ö –≤–µ–ª–∏–∫–∏—Ö —Ñ–∞–π–ª—ñ–≤. –°–ø—Ä–æ–±—É–π—Ç–µ –∑ –º–µ–Ω—à–∏–º–∏ —Ñ–∞–π–ª–∞–º–∏.';
                        }
                        
                        showToast(`–ü–æ–º–∏–ª–∫–∞: ${errorMessage}`, 'error');
                        resultsContainer.innerHTML = `<p style="color: var(--red);">–ü–æ–º–∏–ª–∫–∞: ${errorMessage}</p>`;
                        resultsContainer.style.display = 'block';
                    } finally {
                        if (timeoutId) {
                            clearTimeout(timeoutId);
                        }
                        hideLoader();
                    }
                }, 50);
            });

            // Helper function to estimate operation complexity
            function estimateComplexity(source, target, schema) {
                let complexity = 0;
                
                if (source) complexity += getObjectSize(source);
                if (target) complexity += getObjectSize(target);
                if (schema) complexity += getObjectSize(schema) * 0.5; // Schema validation is generally faster
                
                return complexity;
            }

            // Helper function to estimate object size (recursive count of properties)
            function getObjectSize(obj, depth = 0) {
                if (depth > 20) return 1; // Prevent stack overflow
                if (typeof obj !== 'object' || obj === null) return 1;
                
                let size = 1;
                for (const key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        size += getObjectSize(obj[key], depth + 1);
                    }
                }
                return size;
            }

            document.getElementById('exportTxt').addEventListener('click', (e) => { e.preventDefault(); exportReport('txt'); });
            document.getElementById('exportJson').addEventListener('click', (e) => { e.preventDefault(); exportReport('json'); });
            document.getElementById('exportCsv').addEventListener('click', (e) => { e.preventDefault(); exportReport('csv'); });

            function exportReport(format) {
                let content = '';
                let fileName = `comparison_report_${new Date().toISOString().slice(0,10)}`;
                let mimeType = 'text/plain;charset=utf-8';

                if (globalDifferences.length === 0) {
                    content = "–í—ñ–¥–º—ñ–Ω–Ω–æ—Å—Ç–µ–π –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ.";
                } else if (format === 'txt') {
                    content = globalDifferences.map(d => {
                        let line = `–¢–∏–ø: ${d.type}\n–®–ª—è—Ö: ${d.path}\n–ü—Ä–∏—á–∏–Ω–∞: ${d.reason}\n`;
                        if (d.oldValue !== undefined) line += `–°—Ç–∞—Ä–µ –∑–Ω–∞—á–µ–Ω–Ω—è: ${d.oldValue}\n`;
                        if (d.newValue !== undefined) line += `–ù–æ–≤–µ –∑–Ω–∞—á–µ–Ω–Ω—è: ${d.newValue}\n`;
                        return line + '---';
                    }).join('\n');
                    fileName += '.txt';
                } else if (format === 'json') {
                    content = JSON.stringify(globalDifferences, null, 2);
                    fileName += '.json';
                    mimeType = 'application/json;charset=utf-8';
                } else if (format === 'csv') {
                    const header = "Type,Path,Reason,OldValue,NewValue\n";
                    const rows = globalDifferences.map(d => {
                        const escapeCsv = (val) => {
                            if (val == null) return '';
                            const str = String(val);
                            if (str.includes('"') || str.includes(',') || str.includes('\n')) {
                                return `"${str.replace(/"/g, '""')}"`;
                            }
                            return str;
                        };
                        return [escapeCsv(d.type), escapeCsv(d.path), escapeCsv(d.reason), escapeCsv(d.oldValue), escapeCsv(d.newValue)].join(',');
                    }).join('\n');
                    content = "\uFEFF" + header + rows;
                    fileName += '.csv';
                    mimeType = 'text/csv;charset=utf-8';
                }
                
                const blob = new Blob([content], { type: mimeType });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showToast(`–ó–≤—ñ—Ç –µ–∫—Å–ø–æ—Ä—Ç–æ–≤–∞–Ω–æ —É ${format.toUpperCase()} —Ñ–æ—Ä–º–∞—Ç.`, 'success');
            }
            
            function isPathIgnored(path, ignorePatterns) {
                return ignorePatterns.some(pattern => {
                    let regexPattern = '^' + pattern.replace(/\$/g, '\\$').replace(/\./g, '\\.').replace(/\[\*\]/g, '\\[[0-9]+\\]');
                    if (pattern.endsWith('.*')) {
                        regexPattern = regexPattern.slice(0, -2) + '(\\.|$).*';
                    } else if (pattern.endsWith('[*]')) {
                        regexPattern = regexPattern.slice(0, -3) + '\\[[0-9]+\\](\\.|$).*';
                    }
                    const regex = new RegExp(regexPattern);
                    return regex.test(path);
                });
            }

            // --- CORE COMPARISON LOGIC ---
            function findDifferences(elem1, elem2, keysOnly, path = '$', settings) {
                if (isPathIgnored(path, settings.ignorePaths)) return [];
                const differences = [];
                if (typeof elem1 !== typeof elem2 || Array.isArray(elem1) !== Array.isArray(elem2)) {
                    differences.push({ path, type: 'TypeChanged', reason: '–†—ñ–∑–Ω—ñ —Ç–∏–ø–∏', oldValue: typeof elem1, newValue: typeof elem2 });
                    return differences;
                }
                if (Array.isArray(elem1)) {
                    if (settings.arrayCompareMode === 'key' && !tryCompareArraysByKey(elem1, elem2, keysOnly, path, differences, settings)) {
                        compareArraysByIndex(elem1, elem2, keysOnly, path, differences, settings);
                    } else if (settings.arrayCompareMode === 'index') {
                        compareArraysByIndex(elem1, elem2, keysOnly, path, differences, settings);
                    }
                } else if (typeof elem1 === 'object' && elem1 !== null) {
                    compareObjects(elem1, elem2, keysOnly, path, differences, settings);
                } else {
                    let val1 = elem1;
                    let val2 = elem2;
                    if (typeof val1 === 'string' && !settings.caseSensitive) {
                        val1 = val1.toLowerCase();
                        val2 = val2.toLowerCase();
                    }
                    if (!keysOnly && val1 !== val2) {
                        differences.push({ path, type: 'ValueChanged', reason: '–†—ñ–∑–Ω—ñ –∑–Ω–∞—á–µ–Ω–Ω—è', oldValue: JSON.stringify(elem1), newValue: JSON.stringify(elem2) });
                    }
                }
                return differences;
            }

            function compareObjects(obj1, obj2, keysOnly, path, differences, settings) {
                const allKeys = new Set([...Object.keys(obj1), ...Object.keys(obj2)]);
                allKeys.forEach(key => {
                    const currentPath = `${path}.${key}`;
                    if (isPathIgnored(currentPath, settings.ignorePaths)) return;
                    if (key in obj1 && !(key in obj2)) {
                        differences.push({ path: currentPath, type: 'Removed', reason: '–í–ª–∞—Å—Ç–∏–≤—ñ—Å—Ç—å –≤–∏–¥–∞–ª–µ–Ω–∞', oldValue: JSON.stringify(obj1[key], null, 2) });
                    } else if (!(key in obj1) && key in obj2) {
                        differences.push({ path: currentPath, type: 'Added', reason: '–í–ª–∞—Å—Ç–∏–≤—ñ—Å—Ç—å –¥–æ–¥–∞–Ω–∞', newValue: JSON.stringify(obj2[key], null, 2) });
                    } else {
                        differences.push(...findDifferences(obj1[key], obj2[key], keysOnly, currentPath, settings));
                    }
                });
            }
            
            function tryCompareArraysByKey(arr1, arr2, keysOnly, path, differences, settings) {
                const potentialKeys = ['id', 'productId', 'variantId', 'reviewId', 'key', 'name'];
                if (arr1.length === 0 && arr2.length === 0) return true;
                if (arr1.length > 0 && (typeof arr1[0] !== 'object' || arr1[0] === null)) return false;
                if (arr2.length > 0 && (typeof arr2[0] !== 'object' || arr2[0] === null)) return false;

                const bestKey = potentialKeys.find(key => 
                    (arr1.length === 0 || arr1.every(item => item && typeof item === 'object' && key in item)) &&
                    (arr2.length === 0 || arr2.every(item => item && typeof item === 'object' && key in item))
                );
                
                if (!bestKey) return false;

                const dict1 = new Map(arr1.map(item => [item[bestKey], item]));
                const dict2 = new Map(arr2.map(item => [item[bestKey], item]));

                dict1.forEach((value, key) => {
                    const currentPath = `${path}[${bestKey}=${JSON.stringify(key)}]`;
                    if (isPathIgnored(currentPath, settings.ignorePaths)) return;
                    if (!dict2.has(key)) {
                        differences.push({ path: currentPath, type: 'Removed', reason: '–û–±\'—î–∫—Ç –≤–∏–¥–∞–ª–µ–Ω–æ', oldValue: JSON.stringify(value, null, 2) });
                    } else {
                        differences.push(...findDifferences(value, dict2.get(key), keysOnly, currentPath, settings));
                        dict2.delete(key);
                    }
                });

                dict2.forEach((value, key) => {
                    const currentPath = `${path}[${bestKey}=${JSON.stringify(key)}]`;
                    if (isPathIgnored(currentPath, settings.ignorePaths)) return;
                    if (!dict1.has(key)) {
                        differences.push({ path: currentPath, type: 'Added', reason: '–û–±\'—î–∫—Ç –¥–æ–¥–∞–Ω–æ', newValue: JSON.stringify(value, null, 2) });
                    }
                });
                return true;
            }

            function compareArraysByIndex(arr1, arr2, keysOnly, path, differences, settings) {
                if (arr1.length !== arr2.length && !keysOnly) {
                    differences.push({ path, type: 'LengthChanged', reason: '–†—ñ–∑–Ω–∞ –∫—ñ–ª—å–∫—ñ—Å—Ç—å –µ–ª–µ–º–µ–Ω—Ç—ñ–≤', oldValue: arr1.length, newValue: arr2.length });
                }
                const len = Math.min(arr1.length, arr2.length);
                for (let i = 0; i < len; i++) {
                    const currentPath = `${path}[${i}]`;
                    if (isPathIgnored(currentPath, settings.ignorePaths)) continue;
                    differences.push(...findDifferences(arr1[i], arr2[i], keysOnly, currentPath, settings));
                }
                for (let i = len; i < arr1.length; i++) {
                    const currentPath = `${path}[${i}]`;
                    if (isPathIgnored(currentPath, settings.ignorePaths)) continue;
                    differences.push({ path: currentPath, type: 'Removed', reason: '–ï–ª–µ–º–µ–Ω—Ç –≤–∏–¥–∞–ª–µ–Ω–æ', oldValue: JSON.stringify(arr1[i], null, 2) });
                }
                for (let i = len; i < arr2.length; i++) {
                    const currentPath = `${path}[${i}]`;
                    if (isPathIgnored(currentPath, settings.ignorePaths)) continue;
                    differences.push({ path: currentPath, type: 'Added', reason: '–ï–ª–µ–º–µ–Ω—Ç –¥–æ–¥–∞–Ω–æ', newValue: JSON.stringify(arr2[i], null, 2) });
                }
            }

            // --- JSON SCHEMA VALIDATION ---
            function validateWithSchema(data, schema) {
                // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—ñ AJV –±—ñ–±–ª—ñ–æ—Ç–µ–∫–∏
                if (!isAjvAvailable()) {
                    return [{
                        path: '$',
                        type: 'SchemaLibraryError',
                        reason: '‚ö†Ô∏è AJV –±—ñ–±–ª—ñ–æ—Ç–µ–∫–∞ –Ω–µ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–∞. –ü–µ—Ä–µ–∑–∞–≤–∞–Ω—Ç–∞–∂—Ç–µ —Å—Ç–æ—Ä—ñ–Ω–∫—É –∞–±–æ –ø–µ—Ä–µ–≤—ñ—Ä—Ç–µ —ñ–Ω—Ç–µ—Ä–Ω–µ—Ç-–∑\'—î–¥–Ω–∞–Ω–Ω—è.',
                        oldValue: 'üîß –†—ñ—à–µ–Ω–Ω—è: F5 –∞–±–æ Ctrl+F5',
                        newValue: 'üì∂ –ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ —ñ–Ω—Ç–µ—Ä–Ω–µ—Ç'
                    }];
                }

                try {
                    // –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è AJV –∑ —Ä–æ–∑—à–∏—Ä–µ–Ω–∏–º–∏ –º–æ–∂–ª–∏–≤–æ—Å—Ç—è–º–∏
                    let ajv;
                    let AjvConstructor = null;
                    
                    // –°–ø—Ä–æ–±—É—î–º–æ —Ä—ñ–∑–Ω—ñ —Å–ø–æ—Å–æ–±–∏ –¥–æ—Å—Ç—É–ø—É –¥–æ AJV
                    if (typeof Ajv !== 'undefined') {
                        AjvConstructor = Ajv;
                    } else if (typeof window.Ajv !== 'undefined') {
                        AjvConstructor = window.Ajv;
                    } else if (typeof window.ajv !== 'undefined') {
                        AjvConstructor = window.ajv;
                    } else if (window.Ajv && window.Ajv.default) {
                        AjvConstructor = window.Ajv.default;
                    }
                    
                    if (!AjvConstructor) {
                        throw new Error('AJV –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∏–π –ø—ñ—Å–ª—è –≤—Å—ñ—Ö —Å–ø—Ä–æ–±');
                    }
                    
                    // –°—Ç–≤–æ—Ä—é—î–º–æ AJV instance –∑ —Ä–æ–∑—à–∏—Ä–µ–Ω–∏–º–∏ –æ–ø—Ü—ñ—è–º–∏
                    const ajvOptions = {
                        allErrors: true,           // –ü–æ–∫–∞–∑—É—î–º–æ –≤—Å—ñ –ø–æ–º–∏–ª–∫–∏, –Ω–µ —Ç—ñ–ª—å–∫–∏ –ø–µ—Ä—à—É
                        verbose: true,             // –î–µ—Ç–∞–ª—å–Ω–∞ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è –ø—Ä–æ –ø–æ–º–∏–ª–∫–∏
                        strict: false,             // –ú–µ–Ω—à —Å—Ç—Ä–æ–≥–∏–π —Ä–µ–∂–∏–º –¥–ª—è —Å—É–º—ñ—Å–Ω–æ—Å—Ç—ñ
                        validateFormats: true,     // –í–∞–ª—ñ–¥–∞—Ü—ñ—è —Ñ–æ—Ä–º–∞—Ç—ñ–≤ (email, date, etc.)
                        addUsedSchema: false,      // –ù–µ –¥–æ–¥–∞–≤–∞—Ç–∏ —Å—Ö–µ–º–∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ
                        inlineRefs: true,         // –û–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è –¥–ª—è $ref
                        loadSchema: false,        // –í—ñ–¥–∫–ª—é—á–∞—î–º–æ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–µ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Å—Ö–µ–º
                        allowUnionTypes: true     // –ü—ñ–¥—Ç—Ä–∏–º–∫–∞ union —Ç–∏–ø—ñ–≤
                    };
                    
                    // –ü–µ—Ä–µ–≤—ñ—Ä–∏–º–æ —á–∏ —Ü–µ —Ñ—É–Ω–∫—Ü—ñ—è-–∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä
                    if (typeof AjvConstructor === 'function') {
                        ajv = new AjvConstructor(ajvOptions);
                    } else if (AjvConstructor.default && typeof AjvConstructor.default === 'function') {
                        ajv = new AjvConstructor.default(ajvOptions);
                    } else {
                        throw new Error('AJV –Ω–µ —î –≤–∞–ª—ñ–¥–Ω–∏–º –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–æ–º');
                    }

                    // –î–æ–¥–∞—î–º–æ —Ñ–æ—Ä–º–∞—Ç–∏ —è–∫—â–æ –¥–æ—Å—Ç—É–ø–Ω—ñ
                    if (typeof addFormats !== 'undefined') {
                        try {
                            addFormats(ajv);
                            console.log('‚úÖ AJV Formats –¥–æ–¥–∞–Ω–æ —É—Å–ø—ñ—à–Ω–æ');
                        } catch (e) {
                            console.warn('‚ö†Ô∏è –ü–æ–º–∏–ª–∫–∞ –¥–æ–¥–∞–≤–∞–Ω–Ω—è AJV Formats:', e.message);
                        }
                    } else if (typeof window.addFormats !== 'undefined') {
                        try {
                            window.addFormats(ajv);
                            console.log('‚úÖ AJV Formats –¥–æ–¥–∞–Ω–æ —É—Å–ø—ñ—à–Ω–æ (window)');
                        } catch (e) {
                            console.warn('‚ö†Ô∏è –ü–æ–º–∏–ª–∫–∞ –¥–æ–¥–∞–≤–∞–Ω–Ω—è AJV Formats (window):', e.message);
                        }
                    }

                    // –î–æ–¥–∞—î–º–æ keywords —è–∫—â–æ –¥–æ—Å—Ç—É–ø–Ω—ñ
                    if (typeof addKeywords !== 'undefined') {
                        try {
                            addKeywords(ajv);
                            console.log('‚úÖ AJV Keywords –¥–æ–¥–∞–Ω–æ —É—Å–ø—ñ—à–Ω–æ');
                        } catch (e) {
                            console.warn('‚ö†Ô∏è –ü–æ–º–∏–ª–∫–∞ –¥–æ–¥–∞–≤–∞–Ω–Ω—è AJV Keywords:', e.message);
                        }
                    } else if (typeof window.addKeywords !== 'undefined') {
                        try {
                            window.addKeywords(ajv);
                            console.log('‚úÖ AJV Keywords –¥–æ–¥–∞–Ω–æ —É—Å–ø—ñ—à–Ω–æ (window)');
                        } catch (e) {
                            console.warn('‚ö†Ô∏è –ü–æ–º–∏–ª–∫–∞ –¥–æ–¥–∞–≤–∞–Ω–Ω—è AJV Keywords (window):', e.message);
                        }
                    }

                    // –ö–æ–º–ø—ñ–ª—é—î–º–æ —Å—Ö–µ–º—É –∑ –æ–±—Ä–æ–±–∫–æ—é –ø–æ–º–∏–ª–æ–∫
                    let validate;
                    try {
                        validate = ajv.compile(schema);
                    } catch (compileError) {
                        return [{
                            path: '$',
                            type: 'SchemaCompileError',
                            reason: `üö´ –ü–æ–º–∏–ª–∫–∞ –∫–æ–º–ø—ñ–ª—è—Ü—ñ—ó —Å—Ö–µ–º–∏: ${compileError.message}`,
                            oldValue: 'üìã –ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å —Å—Ö–µ–º–∏',
                            newValue: 'üîß –í–∏–ø—Ä–∞–≤—Ç–µ –ø–æ–º–∏–ª–∫–∏ –≤ JSON Schema'
                        }];
                    }

                    // –í–∏–∫–æ–Ω—É—î–º–æ –≤–∞–ª—ñ–¥–∞—Ü—ñ—é
                    const valid = validate(data);
                    
                    if (valid) {
                        const schemaInfo = getSchemaInfo(schema);
                        return [{
                            path: '$',
                            type: 'SchemaValidationSuccess',
                            reason: `‚úÖ JSON —É—Å–ø—ñ—à–Ω–æ –ø—Ä–æ–π—à–æ–≤ –≤–∞–ª—ñ–¥–∞—Ü—ñ—é –∑–∞ —Å—Ö–µ–º–æ—é ${schemaInfo}`,
                            oldValue: 'üéØ –í—Å—ñ –ø—Ä–∞–≤–∏–ª–∞ —Å—Ö–µ–º–∏ –¥–æ—Ç—Ä–∏–º–∞–Ω–æ',
                            newValue: '‚ú® –î–∞–Ω—ñ –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—é—Ç—å –≤—Å—ñ–º –≤–∏–º–æ–≥–∞–º'
                        }];
                    }
                    
                    // –û–±—Ä–æ–±–ª—è—î–º–æ –ø–æ–º–∏–ª–∫–∏ –≤–∞–ª—ñ–¥–∞—Ü—ñ—ó –∑ –¥–æ–¥–∞—Ç–∫–æ–≤–æ—é —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—î—é
                    return (validate.errors || []).map((err, index) => {
                        const errorPath = err.instancePath || err.dataPath || '$';
                        const errorValue = err.data !== undefined ? err.data : 'undefined';
                        
                        // –§–æ—Ä–º—É—î–º–æ –¥–µ—Ç–∞–ª—å–Ω–∏–π –æ–ø–∏—Å –ø–æ–º–∏–ª–∫–∏
                        let detailedReason = formatValidationError(err);
                        
                        // –î–æ–¥–∞—î–º–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç –ø–æ–º–∏–ª–∫–∏
                        let contextInfo = '';
                        if (err.schemaPath) {
                            contextInfo = `Schema path: ${err.schemaPath}`;
                        }
                        
                        return {
                            path: errorPath,
                            type: getErrorType(err.keyword),
                            reason: detailedReason,
                            oldValue: `${contextInfo} | Expected: ${getExpectedValue(err)}`,
                            newValue: `Actual: ${JSON.stringify(errorValue, null, 2)}`
                        };
                    });
                } catch (e) {
                    console.error('Schema validation error:', e);
                    return [{
                        path: '$',
                        type: 'SchemaParseError',
                        reason: `–ü–æ–º–∏–ª–∫–∞ –≤–∞–ª—ñ–¥–∞—Ü—ñ—ó —Å—Ö–µ–º–∏: ${e.message}`,
                        oldValue: 'Schema compilation failed',
                        newValue: 'Check schema format'
                    }];
                }
            }

            // --- HELPER FUNCTIONS FOR SCHEMA VALIDATION ---
            
            // –û—Ç—Ä–∏–º—É—î–º–æ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ —Å—Ö–µ–º—É
            function getSchemaInfo(schema) {
                let info = '';
                if (schema.title) info += `"${schema.title}"`;
                if (schema.version) info += ` v${schema.version}`;
                if (schema.$schema) {
                    const schemaVersion = schema.$schema.match(/draft-(\d+)/);
                    if (schemaVersion) info += ` (Draft ${schemaVersion[1]})`;
                }
                return info || 'Custom Schema';
            }

            // –§–æ—Ä–º–∞—Ç—É—î–º–æ –ø–æ–º–∏–ª–∫—É –≤–∞–ª—ñ–¥–∞—Ü—ñ—ó –∑ –µ–º–æ–¥–∂—ñ —Ç–∞ –¥–µ—Ç–∞–ª—è–º–∏
            function formatValidationError(err) {
                const keyword = err.keyword || 'unknown';
                const message = err.message || '–ü–æ–º–∏–ª–∫–∞ –≤–∞–ª—ñ–¥–∞—Ü—ñ—ó';
                
                switch (keyword) {
                    case 'required':
                        return `üî¥ –û–±–æ–≤'—è–∑–∫–æ–≤–µ –ø–æ–ª–µ –≤—ñ–¥—Å—É—Ç–Ω—î: ${err.params?.missingProperty || '–Ω–µ–≤—ñ–¥–æ–º–µ'}`;
                    case 'type':
                        return `üî∏ –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∏–π —Ç–∏–ø –¥–∞–Ω–∏—Ö: ${message}`;
                    case 'format':
                        return `üìß –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∏–π —Ñ–æ—Ä–º–∞—Ç: ${message} (–æ—á—ñ–∫—É—î—Ç—å—Å—è ${err.params?.format})`;
                    case 'minimum':
                        return `üìè –ó–Ω–∞—á–µ–Ω–Ω—è –∑–∞–Ω–∞–¥—Ç–æ –º–∞–ª–µ: ${message} (–º—ñ–Ω—ñ–º—É–º: ${err.params?.limit})`;
                    case 'maximum':
                        return `üìè –ó–Ω–∞—á–µ–Ω–Ω—è –∑–∞–Ω–∞–¥—Ç–æ –≤–µ–ª–∏–∫–µ: ${message} (–º–∞–∫—Å–∏–º—É–º: ${err.params?.limit})`;
                    case 'minLength':
                        return `üìù –†—è–¥–æ–∫ –∑–∞–Ω–∞–¥—Ç–æ –∫–æ—Ä–æ—Ç–∫–∏–π: ${message} (–º—ñ–Ω—ñ–º—É–º: ${err.params?.limit} —Å–∏–º–≤–æ–ª—ñ–≤)`;
                    case 'maxLength':
                        return `üìù –†—è–¥–æ–∫ –∑–∞–Ω–∞–¥—Ç–æ –¥–æ–≤–≥–∏–π: ${message} (–º–∞–∫—Å–∏–º—É–º: ${err.params?.limit} —Å–∏–º–≤–æ–ª—ñ–≤)`;
                    case 'pattern':
                        return `üîç –ù–µ –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—î —à–∞–±–ª–æ–Ω—É: ${message}`;
                    case 'enum':
                        return `üéØ –ù–µ–¥–æ–∑–≤–æ–ª–µ–Ω–µ –∑–Ω–∞—á–µ–Ω–Ω—è: ${message}. –î–æ–∑–≤–æ–ª–µ–Ω—ñ: ${JSON.stringify(err.params?.allowedValues)}`;
                    case 'additionalProperties':
                        return `üö´ –ó–∞–±–æ—Ä–æ–Ω–µ–Ω—ñ –¥–æ–¥–∞—Ç–∫–æ–≤—ñ –≤–ª–∞—Å—Ç–∏–≤–æ—Å—Ç—ñ: ${err.params?.additionalProperty}`;
                    case 'minItems':
                        return `üìã –ú–∞—Å–∏–≤ –∑–∞–Ω–∞–¥—Ç–æ –∫–æ—Ä–æ—Ç–∫–∏–π: ${message} (–º—ñ–Ω—ñ–º—É–º: ${err.params?.limit} –µ–ª–µ–º–µ–Ω—Ç—ñ–≤)`;
                    case 'maxItems':
                        return `üìã –ú–∞—Å–∏–≤ –∑–∞–Ω–∞–¥—Ç–æ –¥–æ–≤–≥–∏–π: ${message} (–º–∞–∫—Å–∏–º—É–º: ${err.params?.limit} –µ–ª–µ–º–µ–Ω—Ç—ñ–≤)`;
                    case 'uniqueItems':
                        return `üîÑ –î—É–±–ª—ñ–∫–∞—Ç–∏ –≤ –º–∞—Å–∏–≤—ñ: ${message}`;
                    case 'const':
                        return `üéØ –ó–Ω–∞—á–µ–Ω–Ω—è –º–∞—î –¥–æ—Ä—ñ–≤–Ω—é–≤–∞—Ç–∏: ${JSON.stringify(err.params?.allowedValue)}`;
                    case 'multipleOf':
                        return `üî¢ –ß–∏—Å–ª–æ –º–∞—î –±—É—Ç–∏ –∫—Ä–∞—Ç–Ω–∏–º ${err.params?.multipleOf}`;
                    case 'if':
                        return `üîÄ –£–º–æ–≤–Ω–∞ –≤–∞–ª—ñ–¥–∞—Ü—ñ—è: ${message}`;
                    case 'not':
                        return `‚ùå –ó–∞–±–æ—Ä–æ–Ω–µ–Ω–µ –∑–Ω–∞—á–µ–Ω–Ω—è: ${message}`;
                    case 'oneOf':
                        return `1Ô∏è‚É£ –ú–∞—î –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—Ç–∏ —Ä—ñ–≤–Ω–æ –æ–¥–Ω—ñ–π —Å—Ö–µ–º—ñ: ${message}`;
                    case 'anyOf':
                        return `üîÄ –ú–∞—î –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—Ç–∏ –ø—Ä–∏–Ω–∞–π–º–Ω—ñ –æ–¥–Ω—ñ–π —Å—Ö–µ–º—ñ: ${message}`;
                    case 'allOf':
                        return `‚úÖ –ú–∞—î –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—Ç–∏ –≤—Å—ñ–º —Å—Ö–µ–º–∞–º: ${message}`;
                    default:
                        return `‚ö†Ô∏è ${message} (–ø—Ä–∞–≤–∏–ª–æ: ${keyword})`;
                }
            }

            // –í–∏–∑–Ω–∞—á–∞—î–º–æ —Ç–∏–ø –ø–æ–º–∏–ª–∫–∏ –¥–ª—è –∫—Ä–∞—â–æ—ó –∫–∞—Ç–µ–≥–æ—Ä–∏–∑–∞—Ü—ñ—ó
            function getErrorType(keyword) {
                const typeMap = {
                    'required': 'SchemaRequiredError',
                    'type': 'SchemaTypeError',
                    'format': 'SchemaFormatError',
                    'minimum': 'SchemaRangeError',
                    'maximum': 'SchemaRangeError',
                    'minLength': 'SchemaLengthError',
                    'maxLength': 'SchemaLengthError',
                    'pattern': 'SchemaPatternError',
                    'enum': 'SchemaEnumError',
                    'additionalProperties': 'SchemaPropertiesError',
                    'minItems': 'SchemaArrayError',
                    'maxItems': 'SchemaArrayError',
                    'uniqueItems': 'SchemaArrayError',
                    'const': 'SchemaConstError',
                    'multipleOf': 'SchemaNumericError',
                    'if': 'SchemaConditionalError',
                    'not': 'SchemaNegationError',
                    'oneOf': 'SchemaCompositionError',
                    'anyOf': 'SchemaCompositionError',
                    'allOf': 'SchemaCompositionError'
                };
                return typeMap[keyword] || 'SchemaError';
            }

            // –í–∏–∑–Ω–∞—á–∞—î–º–æ –æ—á—ñ–∫—É–≤–∞–Ω–µ –∑–Ω–∞—á–µ–Ω–Ω—è –¥–ª—è –ø–æ–º–∏–ª–∫–∏
            function getExpectedValue(err) {
                const keyword = err.keyword;
                const params = err.params || {};
                
                switch (keyword) {
                    case 'type':
                        return params.type || 'correct type';
                    case 'format':
                        return `${params.format} format`;
                    case 'minimum':
                        return `>= ${params.limit}`;
                    case 'maximum':
                        return `<= ${params.limit}`;
                    case 'minLength':
                        return `length >= ${params.limit}`;
                    case 'maxLength':
                        return `length <= ${params.limit}`;
                    case 'pattern':
                        return `pattern: ${params.pattern}`;
                    case 'enum':
                        return `one of: ${JSON.stringify(params.allowedValues)}`;
                    case 'const':
                        return JSON.stringify(params.allowedValue);
                    case 'minItems':
                        return `array length >= ${params.limit}`;
                    case 'maxItems':
                        return `array length <= ${params.limit}`;
                    case 'multipleOf':
                        return `multiple of ${params.multipleOf}`;
                    case 'required':
                        return `property "${params.missingProperty}" present`;
                    default:
                        return 'valid value';
                }
            }

            // --- REPORT GENERATION ---
            function renderReport(differences, sourceJson, targetJson) {
                let reportHtml = ``;
                
                // Check for successful schema validation
                const hasSuccessValidation = differences.some(d => d.type === 'SchemaValidationSuccess');
                const errorDifferences = differences.filter(d => d.type !== 'SchemaValidationSuccess');
                
                if (differences.length === 0 || hasSuccessValidation) {
                    if (currentMode === 'schema' && hasSuccessValidation) {
                        const successMsg = differences.find(d => d.type === 'SchemaValidationSuccess');
                        reportHtml = `<div class="schema-success">
                            <h2>‚úÖ ${successMsg ? successMsg.reason : 'JSON –≤–∞–ª—ñ–¥–Ω–∏–π –∑–∞ —Å—Ö–µ–º–æ—é'}</h2>
                            <p>${successMsg ? successMsg.oldValue : '–í—Å—ñ –ø—Ä–∞–≤–∏–ª–∞ —Å—Ö–µ–º–∏ –¥–æ—Ç—Ä–∏–º–∞–Ω–æ'}</p>
                        </div>`;
                    } else {
                        reportHtml = `<h2>‚úÖ ${currentMode === 'schema' ? 'JSON –≤–∞–ª—ñ–¥–Ω–∏–π –∑–∞ —Å—Ö–µ–º–æ—é' : '–í—ñ–¥–º—ñ–Ω–Ω–æ—Å—Ç–µ–π –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ'}.</h2>`;
                    }
                } else {
                    // Add Analytics Dashboard for meaningful data
                    if (errorDifferences.length > 3) {
                        const analytics = createAnalyticsDashboard(errorDifferences, sourceJson, targetJson);
                        resultsContainer.appendChild(analytics);
                    }
                    const stats = errorDifferences.reduce((acc, diff) => {
                        if (diff.type.toLowerCase().includes('add')) acc.added++;
                        else if (diff.type.toLowerCase().includes('remov')) acc.removed++;
                        else acc.changed++;
                        return acc;
                    }, { added: 0, removed: 0, changed: 0 });
                    
                    reportHtml = `
                        <div class="collapsible-section collapsed">
                            <button class="collapsible-header">
                                <h2>–î–µ—Ç–∞–ª—å–Ω–∏–π –∑–≤—ñ—Ç –ø—Ä–æ –≤—ñ–¥–º—ñ–Ω–Ω–æ—Å—Ç—ñ</h2>
                                <span class="collapse-icon">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                                </span>
                            </button>
                            <div class="collapsible-content">
                                <div>
                                    <div class="stats-bar">
                                        <span class="stat-item stat-item-total">
                                            <span class="icon-circle icon-circle-total">Œ£</span> 
                                            <strong>–í—Å—å–æ–≥–æ ${currentMode === 'schema' ? '–ø–æ–º–∏–ª–æ–∫ –≤–∞–ª—ñ–¥–∞—Ü—ñ—ó' : '–≤—ñ–¥–º—ñ–Ω–Ω–æ—Å—Ç–µ–π'}: ${errorDifferences.length}</strong>
                                        </span>
                                        <div class="stats-divider"></div>
                                        <span class="stat-item"><span class="icon-circle icon-circle-added">+</span> –î–æ–¥–∞–Ω–æ: ${stats.added}</span>
                                        <span class="stat-item"><span class="icon-circle icon-circle-removed">-</span> –í–∏–¥–∞–ª–µ–Ω–æ: ${stats.removed}</span>
                                        <span class="stat-item"><span class="icon-circle icon-circle-changed">‚áÑ</span> –ó–º—ñ–Ω–µ–Ω–æ: ${stats.changed}</span>
                                    </div>
                                    <div class="diff-header">
                                        <div class="diff-title">–†–µ–∑—É–ª—å—Ç–∞—Ç–∏ –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è</div>
                                        <div class="diff-controls">
                                            <div class="view-toggle">
                                                <button id="tableViewBtn" class="active" data-view="table">üìä –¢–∞–±–ª–∏—Ü—è</button>
                                                <button id="groupedViewBtn" data-view="grouped">üìÅ –ì—Ä—É–ø–∏</button>
                                                <button id="treeViewBtn" data-view="tree">üå≥ –î–µ—Ä–µ–≤–æ</button>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="results-controls">
                                        <input type="search" id="searchInput" placeholder="üîç –ü–æ—à—É–∫ –∑–∞ —à–ª—è—Ö–æ–º, —Ç–∏–ø–æ–º –∞–±–æ –∑–Ω–∞—á–µ–Ω–Ω—è–º...">
                                        <div class="filter-group">
                                            <label><input type="checkbox" class="filter-cb" value="add" checked> –î–æ–¥–∞–Ω—ñ</label>
                                            <label><input type="checkbox" class="filter-cb" value="remov" checked> –í–∏–¥–∞–ª–µ–Ω—ñ</label>
                                            <label><input type="checkbox" class="filter-cb" value="chang" checked> –ó–º—ñ–Ω–µ–Ω—ñ</label>
                                            ${currentMode === 'schema' ? `<label><input type="checkbox" class="filter-cb" value="schema" checked> –ü–æ–º–∏–ª–∫–∏ —Å—Ö–µ–º–∏</label>` : ''}
                                        </div>
                                                                <select id="importanceFilter" style="padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--bg-color); color: var(--text-color);" title="–ö—Ä–∏—Ç–µ—Ä—ñ—ó –≤–∞–∂–ª–∏–≤–æ—Å—Ç—ñ:&#10;üî¥ –ö—Ä–∏—Ç–∏—á–Ω–∞ - —Å—Ö–µ–º–∏, ID, –∫–ª—é—á—ñ&#10;üü° –í–∏—Å–æ–∫–∞ - —Ç–∏–ø–∏, —Å—Ç–∞—Ç—É—Å–∏, —Å—Ç–∞–Ω–∏&#10;üü¢ –°–µ—Ä–µ–¥–Ω—è - –∑–Ω–∞—á–µ–Ω–Ω—è, —ñ–º–µ–Ω–∞, –∑–∞–≥–æ–ª–æ–≤–∫–∏&#10;‚ö™ –ù–∏–∑—å–∫–∞ - –≤—Å–µ —ñ–Ω—à–µ">
                            <option value="">–í—Å—è –≤–∞–∂–ª–∏–≤—ñ—Å—Ç—å</option>
                            <option value="critical">üî¥ –ö—Ä–∏—Ç–∏—á–Ω–∞</option>
                            <option value="high">üü° –í–∏—Å–æ–∫–∞</option>
                            <option value="medium">üü¢ –°–µ—Ä–µ–¥–Ω—è</option>
                            <option value="low">‚ö™ –ù–∏–∑—å–∫–∞</option>
                        </select>
                                    </div>
                                    <div class="results-layout">
                                        <div class="results-main">
                                            <div id="table-container"></div>
                                        </div>
                                        <div class="results-sidebar" id="minimap-sidebar"></div>
                                    </div>
                                </div>
                            </div>
                        </div>`;
                }
                
                const sourceTitle = currentMode === 'schema' ? 'JSON Schema' : 'Source';
                const targetTitle = currentMode === 'schema' ? 'JSON –¥–ª—è –≤–∞–ª—ñ–¥–∞—Ü—ñ—ó' : 'Target';

                // Use the new rendering function that handles syntax and diff highlighting
                const sourceHtmlContent = sourceJson ? jsonTraverseAndRender(sourceJson, differences, 'source') : '';
                const targetHtmlContent = targetJson ? jsonTraverseAndRender(targetJson, differences, 'target') : '';

                reportHtml += `
                    <div class="collapsible-section collapsed">
                        <button class="collapsible-header">
                            <h2>JSON —Ñ–∞–π–ª–∏</h2>
                            <span class="collapse-icon">
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                            </span>
                        </button>
                        <div class="collapsible-content">
                            <div class="json-view-controls" style="text-align: right; margin-bottom: 10px;">
                                <label><input type="radio" name="jsonViewMode" value="code" checked> –ö–æ–¥</label>
                                <label><input type="radio" name="jsonViewMode" value="tree"> –î–µ—Ä–µ–≤–æ</label>
                            </div>
                            <div class="json-view">
                                <div id="sourceJsonWrapper" style="${sourceJson ? '' : 'display: none;'}">
                                    <h3>${sourceTitle}</h3>
                                    <pre id="sourceJsonViewCode">${sourceHtmlContent}</pre>
                                    <div id="sourceJsonViewTree" class="json-tree-view" style="display: none;"></div>
                                </div>
                                <div id="targetJsonWrapper" style="grid-column: ${sourceJson ? 'auto' : 'span 2'};">
                                    <h3>${targetTitle}</h3>
                                    <pre id="targetJsonViewCode">${targetHtmlContent}</pre>
                                    <div id="targetJsonViewTree" class="json-tree-view" style="display: none;"></div>
                                </div>
                            </div>
                        </div>
                    </div>`;
                
                resultsContainer.innerHTML = reportHtml;
                resultsContainer.style.display = 'block';
                exportBtn.style.display = 'inline-block';
                copyResultsBtn.style.display = 'inline-block';

                renderInteractiveTable(errorDifferences.length > 0 ? errorDifferences : differences);
                synchronizeJsonViewHeights();
                setupCollapsibleSections();
                setupJsonViewToggle(sourceJson, targetJson, differences); // Setup tree view
                resultsContainer.scrollIntoView({ behavior: 'smooth' });
                initializeTooltips(); // Re-initialize tooltips for new dynamic content
            }

            function renderInteractiveTable(allDifferences) {
                const tableContainer = document.getElementById('table-container');
                const minimapSidebar = document.getElementById('minimap-sidebar');
                let searchTerm = '';
                let activeFilters = ['add', 'remov', 'chang'];
                if (currentMode === 'schema') {
                    activeFilters.push('schema');
                }
                let sortState = { column: null, direction: 'asc' };
                let importanceFilter = '';

                // Create and populate minimap for navigation
                if (minimapSidebar && allDifferences.length > 5) {
                    const minimap = createMinimap(allDifferences);
                    minimapSidebar.appendChild(minimap);
                }

                // Setup view mode switching
                setupViewModeControls(allDifferences);

                function applyFiltersAndSort() {
                    let filtered = allDifferences.filter(d => {
                        const typeMatch = activeFilters.some(f => d.type.toLowerCase().includes(f));
                        if (!typeMatch) return false;

                        const searchMatch = !searchTerm || Object.values(d).some(val => 
                            String(val).toLowerCase().includes(searchTerm)
                        );
                        if (!searchMatch) return false;

                        // Apply importance filter
                        if (importanceFilter) {
                            const diffImportance = getImportanceLevel(d);
                            if (diffImportance !== importanceFilter) return false;
                        }

                        return true;
                    });

                    if (sortState.column !== null) {
                        filtered.sort((a, b) => {
                            const valA = a[sortState.column];
                            const valB = b[sortState.column];
                            if (valA === undefined || valB === undefined || valA === null || valB === null) {
                                if (valA === undefined || valA === null) return sortState.direction === 'asc' ? 1 : -1;
                                if (valB === undefined || valB === null) return sortState.direction === 'asc' ? -1 : 1;
                            }
                            if (typeof valA === 'string' && typeof valB === 'string') {
                                return (sortState.direction === 'asc' ? 1 : -1) * valA.localeCompare(valB, 'uk', { numeric: true });
                            }
                            if (valA < valB) return sortState.direction === 'asc' ? -1 : 1;
                            if (valA > valB) return sortState.direction === 'asc' ? 1 : -1;
                            return 0;
                        });
                    }
                    
                    updateTableDOM(filtered);
                }

                async function updateTableDOM(differences) {
                    const LARGE_TABLE_THRESHOLD = 1000;
                    
                    // Show loading indicator for large tables
                    if (differences.length > LARGE_TABLE_THRESHOLD) {
                        tableContainer.innerHTML = '<div style="text-align: center; padding: 20px;">–†–µ–Ω–¥–µ—Ä–∏–Ω–≥ –≤–µ–ª–∏–∫–æ—ó —Ç–∞–±–ª–∏—Ü—ñ...</div>';
                    }

                    const headers = [
                        { key: '', label: '', sortable: false },
                        { key: 'type', label: '–¢–∏–ø', sortable: true },
                        { key: 'path', label: '–®–ª—è—Ö', sortable: true },
                        { key: 'reason', label: '–ü—Ä–∏—á–∏–Ω–∞', sortable: true },
                        { key: 'oldValue', label: currentMode === 'schema' ? '–ü—Ä–∞–≤–∏–ª–æ —Å—Ö–µ–º–∏ / –°—Ç–∞—Ä–µ –∑–Ω–∞—á–µ–Ω–Ω—è' : '–°—Ç–∞—Ä–µ –∑–Ω–∞—á–µ–Ω–Ω—è', sortable: true },
                        { key: 'newValue', label: currentMode === 'schema' ? '–ó–Ω–∞—á–µ–Ω–Ω—è / –ù–æ–≤–µ –∑–Ω–∞—á–µ–Ω–Ω—è' : '–ù–æ–≤–µ –∑–Ω–∞—á–µ–Ω–Ω—è', sortable: true },
                    ];

                    const headerHtml = headers.map((h) => {
                        let classes = h.sortable ? 'sortable' : '';
                        if (h.key === sortState.column) {
                            classes += sortState.direction === 'asc' ? ' sort-asc' : ' sort-desc';
                        }
                        return `<th class="${classes}" data-key="${h.key}">${h.label}</th>`;
                    }).join('');

                    if (differences.length > LARGE_TABLE_THRESHOLD) {
                        // For large tables, use virtual scrolling or pagination
                        const MAX_VISIBLE_ROWS = 500;
                        const visibleDifferences = differences.slice(0, MAX_VISIBLE_ROWS);
                        
                        const rows = await processInChunks(visibleDifferences, (d) => {
                            const iconSymbol = { 
                                Added: '+', Removed: '-', 
                                ValueChanged: '‚áÑ', TypeChanged: 'T', 
                                LengthChanged: 'L', SchemaError: '!',
                                SchemaParseError: 'X'
                            }[d.type] || '?';
                            
                            let iconClass = 'icon-circle';
                            if (d.type.toLowerCase().includes('add')) iconClass += ' icon-circle-added';
                            else if (d.type.toLowerCase().includes('remov')) iconClass += ' icon-circle-removed';
                            else iconClass += ' icon-circle-changed';
                            
                            return `
                                <tr>
                                    <td><span class="${iconClass}">${iconSymbol}</span></td>
                                    <td data-sort-value="${d.type}">${d.type}</td>
                                    <td data-sort-value="${d.path}"><pre>${escapeHtml(d.path)}</pre></td>
                                    <td data-sort-value="${d.reason}">${escapeHtml(d.reason)}</td>
                                    <td><pre>${escapeHtml(d.oldValue || '')}</pre></td>
                                    <td><pre>${escapeHtml(d.newValue || '')}</pre></td>
                                </tr>`;
                        }, 50, 5);

                        const paginationInfo = differences.length > MAX_VISIBLE_ROWS 
                            ? `<p style="text-align: center; margin: 10px 0; color: var(--text-color);">–ü–æ–∫–∞–∑–∞–Ω–æ ${MAX_VISIBLE_ROWS} –∑ ${differences.length} –∑–∞–ø–∏—Å—ñ–≤. –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ —Ñ—ñ–ª—å—Ç—Ä–∏ –¥–ª—è –∑–≤—É–∂–µ–Ω–Ω—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤.</p>`
                            : '';

                        tableContainer.innerHTML = `
                            ${paginationInfo}
                            <table>
                                <thead><tr>${headerHtml}</tr></thead>
                                <tbody>${rows.join('')}</tbody>
                            </table>`;
                    } else {
                        // For smaller tables, render normally
                        const rows = differences.map(d => {
                            const iconSymbol = { 
                                Added: '+', Removed: '-', 
                                ValueChanged: '‚áÑ', TypeChanged: 'T', 
                                LengthChanged: 'L', SchemaError: '!',
                                SchemaParseError: 'X'
                            }[d.type] || '?';
                            
                            let iconClass = 'icon-circle';
                            if (d.type.toLowerCase().includes('add')) iconClass += ' icon-circle-added';
                            else if (d.type.toLowerCase().includes('remov')) iconClass += ' icon-circle-removed';
                            else iconClass += ' icon-circle-changed';
                            
                            const importance = getImportanceLevel(d);
                            const inlineDiff = d.oldValue && d.newValue && typeof d.oldValue === 'string' && typeof d.newValue === 'string' 
                                ? createInlineDiff(d.oldValue, d.newValue) 
                                : null;
                            
                            return `
                                <tr class="importance-${importance}">
                                    <td><span class="${iconClass}">${iconSymbol}</span></td>
                                    <td data-sort-value="${d.type}">${d.type}</td>
                                    <td data-sort-value="${d.path}"><pre>${escapeHtml(d.path)}</pre></td>
                                    <td data-sort-value="${d.reason}">${escapeHtml(d.reason)}</td>
                                    <td><pre>${inlineDiff && d.oldValue ? inlineDiff.split('</span><span class="char-added">')[0] + '</span>' : escapeHtml(d.oldValue || '')}</pre></td>
                                    <td><pre>${inlineDiff && d.newValue ? '<span class="char-added">' + inlineDiff.split('<span class="char-added">')[1] : escapeHtml(d.newValue || '')}</pre></td>
                                </tr>`;
                        }).join('');

                        tableContainer.innerHTML = `
                            <table>
                                <thead><tr>${headerHtml}</tr></thead>
                                <tbody>${rows}</tbody>
                            </table>`;
                    }
                }

                // Use debounced search for better performance
                const debouncedSearch = debounce((searchValue) => {
                    searchTerm = searchValue.toLowerCase();
                    applyFiltersAndSort();
                }, 300);

                document.getElementById('searchInput').addEventListener('input', (e) => {
                    debouncedSearch(e.target.value);
                });

                document.querySelectorAll('.filter-cb').forEach(cb => {
                    cb.addEventListener('change', () => {
                        activeFilters = Array.from(document.querySelectorAll('.filter-cb:checked')).map(c => c.value);
                        applyFiltersAndSort();
                    });
                });

                // Importance filter
                const importanceFilterEl = document.getElementById('importanceFilter');
                if (importanceFilterEl) {
                    importanceFilterEl.addEventListener('change', (e) => {
                        importanceFilter = e.target.value;
                        applyFiltersAndSort();
                    });
                }

                document.getElementById('table-container').addEventListener('click', (e) => { // Use table-container for event delegation
                    const header = e.target.closest('th.sortable');
                    if (header) {
                        const key = header.dataset.key;
                        if (sortState.column === key) {
                            sortState.direction = sortState.direction === 'asc' ? 'desc' : 'asc';
                        } else {
                            sortState.column = key;
                            sortState.direction = 'asc';
                        }
                        applyFiltersAndSort();
                    }
                });

                // Store applyFiltersAndSort globally for view switching
                window.currentApplyFiltersAndSort = applyFiltersAndSort;
                
                applyFiltersAndSort();
            }
            
            // --- These functions are now defined globally to avoid duplication ---

            if (clearAllBtn) {
                clearAllBtn.addEventListener('click', () => {
                    const sourceText = document.getElementById('sourceText');
                    const targetText = document.getElementById('targetText');
                    const schemaText = document.getElementById('schemaText');
                    const fileName1 = document.getElementById('fileName1');
                    const fileName2 = document.getElementById('fileName2');
                    const fileNameSchema = document.getElementById('fileNameSchema');
                    const sourceError = document.getElementById('sourceError');
                    const targetError = document.getElementById('targetError');
                    const schemaError = document.getElementById('schemaError');

                    if (sourceText) sourceText.value = '';
                    if (targetText) targetText.value = '';
                    if (schemaText) schemaText.value = '';
                    if (fileName1) fileName1.textContent = '';
                    if (fileName2) fileName2.textContent = '';
                    if (fileNameSchema) fileNameSchema.textContent = '';
                    if (sourceError) sourceError.style.display = 'none';
                    if (targetError) targetError.style.display = 'none';
                    if (schemaError) schemaError.style.display = 'none';
                    
                    if (dropZone1) dropZone1.classList.remove('invalid');
                    if (dropZone2) dropZone2.classList.remove('invalid');
                    if (dropZoneSchema) dropZoneSchema.classList.remove('invalid');
                    
                    if (resultsContainer) {
                        resultsContainer.innerHTML = '';
                        resultsContainer.style.display = 'none';
                    }
                    if (exportBtn) exportBtn.style.display = 'none';
                    if (copyResultsBtn) copyResultsBtn.style.display = 'none';
                    
                    sourceFileContent = null;
                    targetFileContent = null;
                    schemaFileContent = null;
                    globalDifferences = [];
                    checkFilesReady();
                    showToast('–í—Å—ñ –ø–æ–ª—è –æ—á–∏—â–µ–Ω–æ!', 'info');
                });
            }

            if (copyResultsBtn) {
                copyResultsBtn.addEventListener('click', () => {
                    const table = resultsContainer?.querySelector('table');
                    if (!table) {
                        showToast('–ù–µ–º–∞—î –∑–≤—ñ—Ç—É –¥–ª—è –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è!', 'info');
                        return;
                    }

                    const headerCells = Array.from(table.querySelectorAll('thead th'));
                    const header = headerCells.map(th => {
                        let text = th.innerText.trim();
                        text = text.replace(/[\u2195\u25B2\u25BC]/g, '').trim(); 
                        return `"${text.replace(/"/g, '""')}"`;
                    }).join(',');

                    const rows = Array.from(table.querySelectorAll('tbody tr')).map(tr => 
                        Array.from(tr.querySelectorAll('td')).map(td => {
                            let cellText = td.querySelector('pre') ? td.querySelector('pre').innerText : td.innerText;
                            return `"${cellText.replace(/"/g, '""')}"`;
                        }).join(',')
                    );
                    
                    const csvContent = [header, ...rows].join('\n');
                    
                    navigator.clipboard.writeText(csvContent).then(() => {
                        showToast('–ó–≤—ñ—Ç —Å–∫–æ–ø—ñ–π–æ–≤–∞–Ω–æ –¥–æ –±—É—Ñ–µ—Ä–∞ –æ–±–º—ñ–Ω—É!', 'success');
                    }).catch(err => {
                        console.error('Failed to copy: ', err);
                        showToast('–ù–µ –≤–¥–∞–ª–æ—Å—è —Å–∫–æ–ø—ñ—é–≤–∞—Ç–∏. –ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ –¥–æ–∑–≤–æ–ª–∏ —É –≤–∞—à–æ–º—É –±—Ä–∞—É–∑–µ—Ä—ñ.', 'error');
                    });
                });
            }

            // --- Width Toggle Logic ---
            if (widthToggleBtn) {
                widthToggleBtn.addEventListener('click', () => {
                    const mainContainer = document.querySelector('.container');
                    if (mainContainer) {
                        mainContainer.classList.toggle('full-width');
                        const isFullWidth = mainContainer.classList.contains('full-width');
                        if (widthEnterIcon) widthEnterIcon.style.display = isFullWidth ? 'none' : 'block';
                        if (widthExitIcon) widthExitIcon.style.display = isFullWidth ? 'block' : 'none';
                        synchronizeJsonViewHeights();
                    }
                });
            }

            // --- Export Logic ---
            if (document.getElementById('exportTxt')) {
                document.getElementById('exportTxt').addEventListener('click', (e) => { 
                    e.preventDefault(); 
                    exportReport('txt'); 
                });
            }
            if (document.getElementById('exportJson')) {
                document.getElementById('exportJson').addEventListener('click', (e) => { 
                    e.preventDefault(); 
                    exportReport('json'); 
                });
            }
            if (document.getElementById('exportCsv')) {
                document.getElementById('exportCsv').addEventListener('click', (e) => { 
                    e.preventDefault(); 
                    exportReport('csv'); 
                });
            }
        });

        // –î–æ–¥–∞—Ç–∫–æ–≤–∞ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞ AJV –ø—ñ—Å–ª—è –ø–æ–≤–Ω–æ–≥–æ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –≤—Å—ñ—Ö —Ä–µ—Å—É—Ä—Å—ñ–≤
        window.addEventListener('load', function() {
            setTimeout(() => {
                console.log('Final AJV availability check after window load:', isAjvAvailable());
                if (!isAjvAvailable() && currentMode === 'schema') {
                    showToast('‚ö†Ô∏è –ë—ñ–±–ª—ñ–æ—Ç–µ–∫–∞ AJV –Ω–µ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–∞. –í–∞–ª—ñ–¥–∞—Ü—ñ—è —Å—Ö–µ–º–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞.', 'error', 7000);
                }
            }, 1000); // –ó–∞—Ç—Ä–∏–º–∫–∞ –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è –≤—Å—ñ—Ö –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∏—Ö –æ–ø–µ—Ä–∞—Ü—ñ–π
        });
    </script>
</body>
</html>
